var tipuesearch = {"pages":[{"title":" Libmbd ","text":"Libmbd At the moment the documentation consists of an automatically generated API reference and a miniature of a user guide in the following paragraph. All mathematical formulas used in the code are documented directly in the source code and rendered in Procedures . Installation instructions can be found in the Readme . The user-facing Fortran API of Libmbd is contained in the mbd module and consists of the mbd_input_t and mbd_calc_t derived types. A mbd_input_t object serves to set various options for the calculation and is used to initialize a mbd_calc_t object, which is then used to actually perform the MBD calculation. use mbd , only : mbd_input_t , mbd_calc_t type ( mbd_input_t ) :: inp type ( mbd_calc_t ) :: calc real ( 8 ) :: energy , gradients ( 3 , 2 ) integer :: code character ( 200 ) :: origin , msg inp % atom_types = [ 'Ar' , 'Ar' ] inp % coords = reshape ([ 0 d0 , 0 d0 , 0 d0 , 0 d0 , 0 d0 , 7.5d0 ], [ 3 , 2 ]) inp % xc = 'pbe' call calc % init ( inp ) call calc % get_exception ( code , origin , msg ) if ( code > 0 ) then print * , msg stop end if call calc % update_vdw_params_from_ratios ([ 0.98d0 , 0.98d0 ]) call calc % evaluate_vdw_method ( energy ) call calc % get_gradients ( gradients ) call calc % destroy ()","tags":"home","loc":"index.html"},{"title":"mbd_ts.f90 – Libmbd","text":"Contents Modules mbd_ts Source Code mbd_ts.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_ts !! Obtaining TS energies. use mbd_constants use mbd_utils , only : shift_idx , tostr use mbd_damping , only : damping_t , damping_fermi use mbd_geom , only : geom_t , supercell_circum implicit none private public :: ts_energy contains function ts_energy ( geom , alpha_0 , C6 , damp ) result ( ene ) !! Get TS energy. type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( damping_t ), intent ( in ) :: damp real ( dp ) :: ene real ( dp ) :: C6_ij , r ( 3 ), r_norm , R_vdw_ij , ene_shell , ene_pair , R_cell ( 3 ), & f_damp integer :: i_shell , i_cell , i_atom , j_atom , range_cell ( 3 ), idx_cell ( 3 ) real ( dp ), parameter :: shell_thickness = 10 d0 logical :: is_periodic is_periodic = allocated ( geom % lattice ) ene = 0 d0 i_shell = 0 do i_shell = i_shell + 1 ene_shell = 0 d0 if ( is_periodic ) then range_cell = supercell_circum ( geom % lattice , i_shell * shell_thickness ) else range_cell = [ 0 , 0 , 0 ] end if idx_cell = [ 0 , 0 , - 1 ] do i_cell = 1 , product ( 1 + 2 * range_cell ) call shift_idx ( idx_cell , - range_cell , range_cell ) if ( is_periodic ) then R_cell = matmul ( geom % lattice , idx_cell ) else R_cell = [ 0 d0 , 0 d0 , 0 d0 ] end if do i_atom = 1 , geom % siz () do j_atom = 1 , i_atom if ( i_cell == 1 ) then if ( i_atom == j_atom ) cycle end if r = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) - R_cell r_norm = sqrt ( sum ( r ** 2 )) if ( r_norm > geom % param % ts_cutoff_radius ) cycle if ( is_periodic ) then if ( r_norm >= i_shell * shell_thickness & . or . r_norm < ( i_shell - 1 ) * shell_thickness ) then cycle end if end if C6_ij = combine_C6 ( & C6 ( i_atom ), C6 ( j_atom ), & alpha_0 ( i_atom ), alpha_0 ( j_atom )) if ( allocated ( damp % r_vdw )) then R_vdw_ij = damp % r_vdw ( i_atom ) + damp % r_vdw ( j_atom ) end if select case ( damp % version ) case ( \"fermi\" ) f_damp = damping_fermi ( r , damp % ts_sr * R_vdw_ij , damp % ts_d ) case ( \"fermi2\" ) f_damp = damping_fermi ( r , damp % ts_sr * R_vdw_ij , damp % ts_d ) ** 2 case ( \"custom\" ) f_damp = damp % damping_custom ( i_atom , j_atom ) end select ene_pair = - C6_ij * f_damp / r_norm ** 6 if ( i_atom == j_atom ) then ene_shell = ene_shell + ene_pair / 2 else ene_shell = ene_shell + ene_pair endif end do ! j_atom end do ! i_atom end do ! i_cell ene = ene + ene_shell if (. not . is_periodic ) exit if ( i_shell > 1 . and . abs ( ene_shell ) < geom % param % ts_energy_accuracy ) exit end do ! i_shell end function elemental function combine_C6 ( C6_i , C6_j , alpha_0_i , alpha_0_j ) result ( C6_ij ) real ( dp ), intent ( in ) :: C6_i , C6_j , alpha_0_i , alpha_0_j real ( dp ) :: C6_ij C6_ij = 2 * C6_i * C6_j / ( alpha_0_j / alpha_0_i * C6_i + alpha_0_i / alpha_0_j * C6_j ) end function end module","tags":"","loc":"sourcefile/mbd_ts.f90.html"},{"title":"mbd.F90 – Libmbd","text":"Contents Modules mbd Source Code mbd.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #include \"defaults.h\" module mbd !! High-level Fortran API. use mbd_constants use mbd_damping , only : damping_t use mbd_formulas , only : scale_with_ratio use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_request_t use mbd_methods , only : get_mbd_energy , get_mbd_scs_energy use mbd_ts , only : ts_energy use mbd_utils , only : result_t , exception_t use mbd_vdw_param , only : ts_vdw_params , tssurf_vdw_params , species_index implicit none private type , public :: mbd_input_t !! Contains user input to an MBD calculation. character ( len = 30 ) :: method = 'mbd-rsscs' !! VdW method to use to calculate energy and gradients. !! !! - `mbd-rsscs`: The MBD@rsSCS method. !! - `mbd-nl`: The MBD-NL method. !! - `ts`: The TS method. !! - `mbd`: Generic MBD method (without any screening). integer :: comm = - 1 !! MPI communicator. !! !! Only used when compiled with MPI. Leave as is to use the !! MPI_COMM_WORLD communicator. logical :: calculate_forces = . true . !! Whether to calculate forces. logical :: calculate_spectrum = . false . !! Whether to keep MBD eigenvalues. real ( dp ) :: ts_ene_acc = TS_ENERGY_ACCURACY !! Required accuracy of the TS energy. real ( dp ) :: ts_f_acc = TS_FORCES_ACCURACY !! Required accuracy of the TS gradients. integer :: n_omega_grid = N_FREQUENCY_GRID !! Number of imaginary frequency grid points. real ( dp ) :: k_grid_shift = K_GRID_SHIFT !! Off-\\Gamma shift of the k-point grid in units of !! inter-k-point distance. logical :: zero_negative_eigvals = . false . !! Whether to zero out negative eigenvalues. character ( len = 20 ) :: xc = '' !! XC functional for automatic setting of damping parameters. real ( dp ) :: ts_d = TS_DAMPING_D !! TS damping parameter d. real ( dp ) :: ts_sr = - 1 !! Custom TS damping parameter s_R. !! !! Leave as is to use a value based on the XC functional. real ( dp ) :: mbd_a = MBD_DAMPING_A !! MBD damping parameter a. real ( dp ) :: mbd_beta = - 1 !! Custom MBD damping parameter \\beta. !! !! Leave as is to use a value based on the XC functional. character ( len = 10 ) :: vdw_params_kind = 'ts' !! Which free-atom reference vdW parameters to use for scaling. !! !! - `ts`: Values from original TS method. !! - `tssurf`: Values from the TS&#94;\\text{surf} approach. character ( len = 3 ), allocatable :: atom_types (:) !! (N) Atom types used for picking free-atom reference values. real ( dp ), allocatable :: free_values (:, :) !! (N\\times3, a.u.) Custom free-atom vdW paramters to use for !! scaling. !! !! Columns contain static polarizabilities, C6 coefficients, and vdW !! radii. real ( dp ), allocatable :: coords (:, :) !! (3\\times N, a.u.) Atomic coordinates. real ( dp ), allocatable :: lattice_vectors (:, :) !! (3\\times 3, a.u.) Lattice vectors in columns, unallocated if not !! periodic. integer :: k_grid ( 3 ) = [ - 1 , - 1 , - 1 ] !! Number of k-points along reciprocal axes. character ( len = 10 ) :: parallel_mode = 'auto' !! Parallelization scheme. !! !! - `auto`: Pick based on system system size and number of k-points. !! - `kpoints`: Parallelize over k-points. !! - `atoms`: Parallelize over atom pairs. end type type , public :: mbd_calc_t !! Represents an MBD calculation. private type ( geom_t ) :: geom type ( damping_t ) :: damp real ( dp ), allocatable :: alpha_0 (:) real ( dp ), allocatable :: C6 (:) character ( len = 30 ) :: method type ( result_t ) :: results type ( grad_t ) :: denergy logical :: calculate_gradients real ( dp ), allocatable :: free_values (:, :) contains procedure :: init => mbd_calc_init procedure :: destroy => mbd_calc_destroy procedure :: update_coords => mbd_calc_update_coords procedure :: update_lattice_vectors => mbd_calc_update_lattice_vectors procedure :: update_vdw_params_custom => mbd_calc_update_vdw_params_custom procedure :: update_vdw_params_from_ratios => mbd_calc_update_vdw_params_from_ratios procedure :: update_vdw_params_nl => mbd_calc_update_vdw_params_nl procedure :: evaluate_vdw_method => mbd_calc_evaluate_vdw_method procedure :: get_gradients => mbd_calc_get_gradients procedure :: get_lattice_derivs => mbd_calc_get_lattice_derivs procedure :: get_spectrum_modes => mbd_calc_get_spectrum_modes procedure :: get_exception => mbd_calc_get_exception end type contains subroutine mbd_calc_init ( this , input ) !! Initialize an MBD calculation from an MBD input. class ( mbd_calc_t ), target , intent ( inout ) :: this type ( mbd_input_t ), intent ( in ) :: input !! MBD input. #ifdef WITH_MPI if ( input % comm /= - 1 ) this % geom % comm = input % comm #endif this % method = input % method this % calculate_gradients = input % calculate_forces if ( input % calculate_spectrum ) then this % geom % get_eigs = . true . this % geom % get_modes = . true . end if this % geom % param % ts_energy_accuracy = input % ts_ene_acc ! TODO ... = input%ts_f_acc this % geom % param % n_freq = input % n_omega_grid this % geom % param % k_grid_shift = input % k_grid_shift this % geom % param % zero_negative_eigvals = input % zero_negative_eigvals if (. not . all ( input % k_grid == - 1 )) this % geom % k_grid = input % k_grid this % geom % coords = input % coords if ( allocated ( input % lattice_vectors )) then if (. not . allocated ( this % geom % k_grid )) then this % geom % exc = exception_t ( & MBD_EXC_INPUT , & 'calc%init()' , & 'Lattice vectors present but no k-grid specified' & ) return end if this % geom % lattice = input % lattice_vectors end if this % geom % parallel_mode = input % parallel_mode call this % geom % init () if ( allocated ( input % free_values )) then this % free_values = input % free_values else select case ( input % vdw_params_kind ) case ( 'ts' ) this % free_values = ts_vdw_params (:, species_index ( input % atom_types )) case ( 'tssurf' ) this % free_values = tssurf_vdw_params (:, species_index ( input % atom_types )) end select end if if ( input % xc == '' ) then this % damp % beta = input % mbd_beta this % damp % a = input % mbd_a this % damp % ts_d = input % ts_d this % damp % ts_sr = input % ts_sr else this % geom % exc = this % damp % set_params_from_xc ( input % xc , input % method ) if ( this % geom % has_exc ()) return end if end subroutine subroutine mbd_calc_destroy ( this ) !! Finalize an MBD calculation. class ( mbd_calc_t ), target , intent ( inout ) :: this call this % geom % destroy () end subroutine subroutine mbd_calc_update_coords ( this , coords ) !! Update atomic coordinates. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: coords (:, :) !! (3\\times N, a.u.) New atomic coordinates. this % geom % coords = coords end subroutine subroutine mbd_calc_update_lattice_vectors ( this , latt_vecs ) !! Update unit-cell lattice vectors. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: latt_vecs (:, :) !! (3\\times 3, a.u.) New lattice vectors in columns. this % geom % lattice = latt_vecs end subroutine subroutine mbd_calc_update_vdw_params_custom ( this , alpha_0 , C6 , r_vdw ) !! Update vdW parameters in a custom way. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: alpha_0 (:) !! (a.u.) New atomic static polarizabilities. real ( dp ), intent ( in ) :: C6 (:) !! (a.u.) New atomic C_6 coefficients. real ( dp ), intent ( in ) :: r_vdw (:) !! (a.u.) New atomic vdW radii. this % alpha_0 = alpha_0 this % C6 = C6 this % damp % r_vdw = r_vdw end subroutine subroutine mbd_calc_update_vdw_params_from_ratios ( this , ratios ) !! Update vdW parameters based on scaling of free-atom values. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: ratios (:) !! Ratios of atomic volumes in the system and in vacuum. real ( dp ), allocatable :: ones (:) allocate ( ones ( size ( ratios )), source = 1 d0 ) this % alpha_0 = scale_with_ratio ( this % free_values ( 1 , :), ratios , ones , 1 d0 ) this % C6 = scale_with_ratio ( this % free_values ( 2 , :), ratios , ones , 2 d0 ) this % damp % r_vdw = scale_with_ratio ( this % free_values ( 3 , :), ratios , ones , 1 d0 / 3 ) end subroutine subroutine mbd_calc_update_vdw_params_nl ( this , alpha_0_ratios , C6_ratios ) !! Update vdW parameters for the MBD-NL method. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: alpha_0_ratios (:) !! Ratios of free-atom exact static polarizabilities and those from the !! VV functional. real ( dp ), intent ( in ) :: C6_ratios (:) !! Ratios of free-atom exact C_6 coefficients and those from the VV !! functional. this % alpha_0 = this % free_values ( 1 , :) * alpha_0_ratios this % C6 = this % free_values ( 2 , :) * C6_ratios this % damp % r_vdw = 2.5d0 * this % free_values ( 1 , :) ** ( 1 d0 / 7 ) * alpha_0_ratios ** ( 1 d0 / 3 ) end subroutine subroutine mbd_calc_evaluate_vdw_method ( this , energy ) !! Evaluate a given vdW method for a given system and vdW parameters, !! retrieve energy. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( out ) :: energy !! (a.u.) VdW energy. type ( grad_request_t ) :: grad if ( this % calculate_gradients ) then grad % dcoords = . true . if ( allocated ( this % geom % lattice )) grad % dlattice = . true . end if select case ( this % method ) case ( 'mbd' , 'mbd-nl' ) this % damp % version = 'fermi,dip' this % results = get_mbd_energy ( & this % geom , this % alpha_0 , this % C6 , this % damp , this % denergy , grad & ) energy = this % results % energy case ( 'mbd-rsscs' ) this % results = get_mbd_scs_energy ( & this % geom , 'rsscs' , this % alpha_0 , this % C6 , this % damp , this % denergy , grad & ) energy = this % results % energy case ( 'ts' ) energy = ts_energy ( this % geom , this % alpha_0 , this % C6 , this % damp ) end select end subroutine subroutine mbd_calc_get_gradients ( this , gradients ) ! 3 by N  dE/dR !! Retrieve nuclear energy gradients if they were requested in the MBD !! input. !! !! The gradients are calculated together with the energy, so a call to this !! method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]].  For the same reason, the !! gradients must be requested prior to this called via !! [[mbd_input_t:calculate_forces]]. class ( mbd_calc_t ), intent ( in ) :: this real ( dp ), intent ( out ) :: gradients (:, :) !! (3\\times N, a.u.) Energy gradients, \\mathrm dE/\\mathrm d\\mathbf !! R_i, index i runs over columns. gradients = transpose ( this % denergy % dcoords ) end subroutine subroutine mbd_calc_get_lattice_derivs ( this , latt_derivs ) !! Provide lattice-vector energy gradients if they were requested in the MBD !! input. !! !! The gradients are actually calculated together with the energy, so a call !! to this method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]].  For the same reason, the !! gradients must be requested prior to this called via !! [[mbd_input_t:calculate_forces]]. class ( mbd_calc_t ), intent ( in ) :: this real ( dp ), intent ( out ) :: latt_derivs (:, :) !! (3\\times 3, a.u.) Energy gradients, \\mathrm dE/\\mathrm d\\mathbf !! a_i, index i runs over columns. latt_derivs = transpose ( this % denergy % dlattice ) end subroutine subroutine mbd_calc_get_spectrum_modes ( this , spectrum , modes ) !! Provide MBD spectrum if it was requested in the MBD input. !! !! The spectrum is actually calculated together with the energy, so a call !! to this method must be preceeded by a call to !! [[mbd_calc_t:evaluate_vdw_method]].  For the same reason, the !! spectrum must be requested prior to this called via !! [[mbd_input_t:calculate_spectrum]]. class ( mbd_calc_t ), intent ( inout ) :: this real ( dp ), intent ( out ) :: spectrum (:) !! (3N, a.u.) Energies (frequencies) of coupled MBD modues, !! \\omega_i. real ( dp ), intent ( out ), allocatable , optional :: modes (:, :) !! (3N\\times 3N) Coupled-mode wave functions (MBD eigenstates), !! \\psi_j, in the basis of uncoupled states, !! C_{ij}=\\langle\\phi_i|\\psi_j\\rangle, index j runs over !! columns. !! !! To save memory, the argument must be allocatable, and the method !! transfers allocation from the internal state to the argument. For !! this reason, the method can be called only once wih this optional !! argument per calculation. spectrum = this % results % mode_eigs if ( present ( modes )) call move_alloc ( this % results % modes , modes ) end subroutine subroutine mbd_calc_get_exception ( this , code , origin , msg ) !! Retrieve an exception in the MBD calculation if it occured. class ( mbd_calc_t ), intent ( inout ) :: this integer , intent ( out ) :: code !! Exception code, values defined in [[mbd_constants]]. character ( * ), intent ( out ) :: origin !! Exception origin. character ( * ), intent ( out ) :: msg !! Exception message. code = this % geom % exc % code if ( code == 0 ) return origin = this % geom % exc % origin msg = this % geom % exc % msg this % geom % exc % code = 0 this % geom % exc % origin = '' this % geom % exc % msg = '' end subroutine end module","tags":"","loc":"sourcefile/mbd.f90.html"},{"title":"mbd_constants.f90 – Libmbd","text":"Contents Modules mbd_constants Source Code mbd_constants.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_constants !! Constants used throughout. implicit none integer , parameter :: dp = kind ( 0.d0 ) real ( dp ), parameter :: pi = acos ( - 1.d0 ) real ( dp ), parameter :: ang = 1.8897259886d0 !! Value of angstrom in atomic units integer , parameter :: MBD_EXC_NEG_EIGVALS = 1 !! Negative eigenvalue exception integer , parameter :: MBD_EXC_NEG_POL = 2 !! Negative polarizability exception integer , parameter :: MBD_EXC_LINALG = 3 !! Exception in LAPACK or ScaLAPACK integer , parameter :: MBD_EXC_UNIMPL = 4 !! Functionality is not implemented integer , parameter :: MBD_EXC_DAMPING = 5 !! Damping-function exception integer , parameter :: MBD_EXC_INPUT = 6 !! Invalid input real ( dp ), parameter :: ZERO_REAL = 0 d0 complex ( dp ), parameter :: ZERO_COMPLEX = ( 0 d0 , 0 d0 ) complex ( dp ), parameter :: IMI = ( 0 d0 , 1 d0 ) end module","tags":"","loc":"sourcefile/mbd_constants.f90.html"},{"title":"mbd_gradients.f90 – Libmbd","text":"Contents Modules mbd_gradients Source Code mbd_gradients.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_gradients !! Derivatives. use mbd_constants implicit none private type , public :: grad_t !! Derivatives with respect to various quantities real ( dp ), allocatable :: dcoords (:, :) ! n_atoms by 3 real ( dp ), allocatable :: dlattice (:, :) ! n_vectors by 3 real ( dp ), allocatable :: dalpha (:) real ( dp ), allocatable :: dalpha_dyn (:, :) ! n_atoms by 0:n_freq real ( dp ), allocatable :: dC6 (:) real ( dp ), allocatable :: dq (:) real ( dp ), allocatable :: dr_vdw (:) real ( dp ), allocatable :: domega (:) real ( dp ), allocatable :: dV (:) real ( dp ), allocatable :: dV_free (:) real ( dp ), allocatable :: dX_free (:) end type type , public :: grad_matrix_re_t !! Derivatives of a real dipole matrix with respect to various quantities real ( dp ), allocatable :: dr (:, :, :) real ( dp ), allocatable :: dlattice (:, :, :, :) real ( dp ), allocatable :: dvdw (:, :) real ( dp ), allocatable :: dsigma (:, :) real ( dp ), allocatable :: dgamma (:, :) end type type , public :: grad_matrix_cplx_t !! Derivatives of a compelx dipole matrix with respect to various quantities complex ( dp ), allocatable :: dr (:, :, :) complex ( dp ), allocatable :: dlattice (:, :, :, :) complex ( dp ), allocatable :: dq (:, :, :) complex ( dp ), allocatable :: dvdw (:, :) complex ( dp ), allocatable :: dsigma (:, :) complex ( dp ), allocatable :: dgamma (:, :) end type type , public :: grad_scalar_t !! Derivatives of a scalar with respect to various quantities real ( dp ), allocatable :: dr (:) real ( dp ), allocatable :: dr_1 real ( dp ), allocatable :: dvdw real ( dp ), allocatable :: dgamma end type type , public :: grad_request_t !! Used to request derivatives with respect to function arguments logical :: dcoords = . false . logical :: dalpha = . false . logical :: dalpha_dyn = . false . logical :: dC6 = . false . logical :: dr_vdw = . false . logical :: domega = . false . logical :: dsigma = . false . logical :: dgamma = . false . logical :: dq = . false . logical :: dlattice = . false . logical :: dV = . false . logical :: dV_free = . false . logical :: dX_free = . false . contains procedure :: any => grad_request_any end type contains logical function grad_request_any ( this ) result ( any ) class ( grad_request_t ), intent ( in ) :: this any = this % dcoords & . or . this % dalpha & . or . this % dalpha_dyn & . or . this % dC6 & . or . this % dr_vdw & . or . this % domega & . or . this % dsigma & . or . this % dgamma & . or . this % dq & . or . this % dlattice & . or . this % dV & . or . this % dV_free & . or . this % dX_free end function end module","tags":"","loc":"sourcefile/mbd_gradients.f90.html"},{"title":"mbd_elsi.F90 – Libmbd","text":"Contents Modules mbd_elsi Source Code mbd_elsi.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef DO_COMPLEX_TYPE module mbd_elsi use elsi , only : elsi_handle , elsi_init , elsi_set_mpi , elsi_set_blacs , & elsi_set_unit_ovlp , elsi_finalize , elsi_ev_real , elsi_ev_complex use mbd_constants use mbd_blacs , only : blacs_desc_t use mbd_utils , only : exception_t , is_true implicit none private public :: elsi_eigh , elsi_eigvalsh interface elsi_eigh module procedure elsi_eigh_real module procedure elsi_eigh_complex end interface interface elsi_eigvalsh module procedure elsi_eigvalsh_real module procedure elsi_eigvalsh_complex end interface contains #   define DO_COMPLEX_TYPE 0 #endif #if DO_COMPLEX_TYPE == 0 subroutine elsi_eigh_real ( A , blacs_desc , eigs , exc , src , vals_only ) real ( dp ), intent ( inout ) :: A (:, :) real ( dp ), intent ( in ), optional :: src (:, :) #elif DO_COMPLEX_TYPE == 1 subroutine elsi_eigh_complex ( A , blacs_desc , eigs , exc , src , vals_only ) complex ( dp ), intent ( inout ) :: A (:, :) complex ( dp ), intent ( in ), optional :: src (:, :) #endif type ( blacs_desc_t ), intent ( in ) :: blacs_desc real ( dp ), intent ( out ) :: eigs (:) type ( exception_t ), intent ( out ), optional :: exc logical , intent ( in ), optional :: vals_only integer :: n_vecs , n type ( elsi_handle ) :: handle #if DO_COMPLEX_TYPE == 0 real ( dp ) :: DUMMY_MATRIX ( 1 , 1 ) real ( dp ), allocatable :: vecs (:, :) #elif DO_COMPLEX_TYPE == 1 complex ( dp ) :: DUMMY_MATRIX ( 1 , 1 ) complex ( dp ), allocatable :: vecs (:, :) #endif n = 3 * blacs_desc % n_atoms if ( present ( src )) A = src if ( is_true ( vals_only )) then n_vecs = 0 else n_vecs = n end if call elsi_init ( handle , 1 , 1 , 0 , n , 0 d0 , n_vecs ) call elsi_set_mpi ( handle , blacs_desc % comm ) call elsi_set_blacs ( handle , blacs_desc % ctx , 3 ) call elsi_set_unit_ovlp ( handle , 1 ) allocate ( vecs ( size ( A , 1 ), size ( A , 2 ))) #if DO_COMPLEX_TYPE == 0 call elsi_ev_real ( handle , A , DUMMY_MATRIX , eigs , vecs ) #elif DO_COMPLEX_TYPE == 1 call elsi_ev_complex ( handle , A , DUMMY_MATRIX , eigs , vecs ) #endif A = vecs call elsi_finalize ( handle ) end subroutine #if DO_COMPLEX_TYPE == 0 function elsi_eigvalsh_real ( A , blacs_desc , exc , destroy ) result ( eigs ) real ( dp ), allocatable , intent ( inout ) :: A (:, :) #elif DO_COMPLEX_TYPE == 1 function elsi_eigvalsh_complex ( A , blacs_desc , exc , destroy ) result ( eigs ) complex ( dp ), allocatable , intent ( inout ) :: A (:, :) #endif type ( blacs_desc_t ), intent ( in ) :: blacs_desc type ( exception_t ), intent ( out ), optional :: exc logical , intent ( in ), optional :: destroy real ( dp ) :: eigs ( 3 * blacs_desc % n_atoms ) #if DO_COMPLEX_TYPE == 0 real ( dp ), allocatable :: A_ (:, :) #elif DO_COMPLEX_TYPE == 1 complex ( dp ), allocatable :: A_ (:, :) #endif if ( is_true ( destroy )) then call move_alloc ( A , A_ ) else A_ = A end if call elsi_eigh ( A_ , blacs_desc , eigs , exc , vals_only = . true .) end function #if DO_COMPLEX_TYPE == 0 #   undef DO_COMPLEX_TYPE #   define DO_COMPLEX_TYPE 1 #   include \"mbd_elsi.F90\" end module #endif","tags":"","loc":"sourcefile/mbd_elsi.f90.html"},{"title":"mbd_methods.F90 – Libmbd","text":"Contents Modules mbd_methods Source Code mbd_methods.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_methods !! Obtaining MBD energies. use mbd_constants use mbd_damping , only : damping_t use mbd_formulas , only : omega_qho , alpha_dyn_qho , scale_with_ratio , C6_from_alpha use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_request_t use mbd_hamiltonian , only : get_mbd_hamiltonian_energy use mbd_lapack , only : eigvals , inverse use mbd_rpa , only : get_mbd_rpa_energy use mbd_scs , only : run_scs use mbd_utils , only : result_t , tostr , quad_pt_t , shift_idx #ifdef WITH_SCALAPACK use mbd_blacs , only : all_reduce #endif implicit none private public :: get_mbd_energy , get_mbd_scs_energy contains type ( result_t ) function get_mbd_energy ( geom , alpha_0 , C6 , damp , dene , grad ) result ( res ) !! Get MBD energy. !! !! For a nonperiodic system, the method just transforms C_6 coefficients !! to frequencies, and performs a single call to !! [[get_mbd_hamiltonian_energy]]. For a periodic system, the method !! integrates the energy over the frist Brillouin zone. !! !!  !! E=\\int_\\text{FBZ}\\mathrm d\\mathbf q\\,E(\\mathbf !! q)\\approx\\frac1{N_k}\\sum_i&#94;{N_k}E(\\mathbf q_i) !! \\\\ \\mathbf q_i=\\boldsymbol{\\mathcal B}\\mathbf n_i,\\qquad\\partial\\mathbf !! q_i=-\\big((\\partial\\boldsymbol{\\mathcal !! A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf q_i !!  type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( damping_t ), intent ( in ) :: damp type ( grad_t ), intent ( out ) :: dene type ( grad_request_t ), intent ( in ) :: grad real ( dp ), allocatable :: alpha (:, :), omega (:), k_pts (:, :), dkdlattice (:, :, :, :) type ( grad_t ), allocatable :: dalpha (:) integer :: n_kpts , i_kpt , a type ( result_t ) :: res_k type ( grad_t ) :: domega , dene_k type ( grad_request_t ) :: grad_ham omega = omega_qho ( C6 , alpha_0 , domega , grad ) if ( geom % do_rpa ) then alpha = alpha_dyn_qho ( alpha_0 , omega , geom % freq , dalpha , grad_request_t ()) end if grad_ham = grad if ( grad % dC6 . or . grad % dalpha ) grad_ham % domega = . true . if ( grad % dlattice ) grad_ham % dq = . true . if (. not . allocated ( geom % lattice )) then if (. not . geom % do_rpa ) then res = get_mbd_hamiltonian_energy ( geom , alpha_0 , omega , damp , dene , grad_ham ) if ( grad % dC6 ) dene % dC6 = dene % domega * domega % dC6 if ( grad % dalpha ) dene % dalpha = dene % dalpha + dene % domega * domega % dalpha if ( allocated ( dene % domega )) deallocate ( dene % domega ) else res = get_mbd_rpa_energy ( geom , alpha , damp ) ! TODO gradients end if else k_pts = make_k_pts ( & geom % k_grid , geom % lattice , geom % param % k_grid_shift , dkdlattice , grad % dlattice & ) n_kpts = size ( k_pts , 2 ) res % energy = 0 d0 if ( geom % get_eigs ) & allocate ( res % mode_eigs_k ( 3 * geom % siz (), n_kpts ), source = 0 d0 ) if ( geom % get_modes ) & allocate ( res % modes_k ( 3 * geom % siz (), 3 * geom % siz (), n_kpts ), source = ( 0 d0 , 0 d0 )) if ( geom % get_rpa_orders ) allocate ( & res % rpa_orders_k ( geom % param % rpa_order_max , n_kpts ), source = 0 d0 & ) if ( grad % dcoords ) allocate ( dene % dcoords ( geom % siz (), 3 ), source = 0 d0 ) if ( grad % dlattice ) allocate ( dene % dlattice ( 3 , 3 ), source = 0 d0 ) if ( grad % dalpha ) allocate ( dene % dalpha ( geom % siz ()), source = 0 d0 ) if ( grad % dC6 ) allocate ( dene % dC6 ( geom % siz ()), source = 0 d0 ) if ( grad % dR_vdw ) allocate ( dene % dR_vdw ( geom % siz ()), source = 0 d0 ) do i_kpt = 1 , n_kpts associate ( k_pt => k_pts (:, i_kpt )) if (. not . geom % do_rpa ) then res_k = get_mbd_hamiltonian_energy ( & geom , alpha_0 , omega , damp , dene_k , grad_ham , k_pt & ) else res_k = get_mbd_rpa_energy ( geom , alpha , damp , k_pt ) end if end associate if ( geom % has_exc ()) return if ( geom % get_eigs ) then res % mode_eigs_k (:, i_kpt ) = res_k % mode_eigs end if if ( geom % get_modes ) then res % modes_k (:, :, i_kpt ) = res_k % modes_k_single end if if ( geom % get_rpa_orders ) then res % rpa_orders_k (:, i_kpt ) = res_k % rpa_orders end if res % energy = res % energy + res_k % energy / n_kpts if ( grad % dcoords ) dene % dcoords = dene % dcoords + dene_k % dcoords / n_kpts if ( grad % dlattice ) then dene % dlattice = dene % dlattice + dene_k % dlattice / n_kpts do a = 1 , 3 dene % dlattice = dene % dlattice & + dene_k % dq ( a ) * dkdlattice ( a , i_kpt , :, :) / n_kpts end do end if if ( grad % dalpha ) then dene % dalpha = dene % dalpha & + ( dene_k % dalpha + dene_k % domega * domega % dalpha ) / n_kpts end if if ( grad % dC6 ) dene % dC6 = dene % dC6 + dene_k % domega * domega % dC6 / n_kpts if ( grad % dR_vdw ) dene % dR_vdw = dene % dR_vdw + dene_k % dR_vdw / n_kpts end do end if end function type ( result_t ) function get_mbd_scs_energy ( & geom , variant , alpha_0 , C6 , damp , dene , grad ) result ( res ) !! Get screened MBD energy. type ( geom_t ), intent ( inout ) :: geom character ( len =* ), intent ( in ) :: variant real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: C6 (:) type ( damping_t ), intent ( in ) :: damp type ( grad_t ), intent ( out ) :: dene type ( grad_request_t ), intent ( in ) :: grad real ( dp ), allocatable :: alpha_dyn (:, :), alpha_dyn_scs (:, :), & C6_scs (:), dC6_scs_dalpha_dyn_scs (:, :), & dene_dalpha_scs_dyn (:, :), freq_w (:), omega (:) type ( grad_t ), allocatable :: dalpha_dyn (:), dalpha_dyn_scs (:, :) type ( grad_t ) :: dene_mbd , dr_vdw_scs , domega type ( grad_request_t ) :: grad_scs type ( damping_t ) :: damp_scs , damp_mbd integer :: n_freq , i_freq , n_atoms , i_atom , my_i_atom character ( len = 15 ) :: damping_types ( 2 ) select case ( variant ) case ( 'scs' ) damping_types = [ character ( len = 15 ) :: 'dip,gg' , 'dip,1mexp' ] case ( 'rsscs' ) damping_types = [ character ( len = 15 ) :: 'fermi,dip,gg' , 'fermi,dip' ] end select n_freq = ubound ( geom % freq , 1 ) n_atoms = geom % siz () allocate ( alpha_dyn ( n_atoms , 0 : n_freq )) allocate ( alpha_dyn_scs ( n_atoms , 0 : n_freq )) allocate ( dalpha_dyn_scs ( size ( geom % idx % i_atom ), 0 : n_freq )) if ( grad % any ()) allocate ( dene_dalpha_scs_dyn ( n_atoms , 0 : n_freq )) omega = omega_qho ( C6 , alpha_0 , domega , grad ) alpha_dyn = alpha_dyn_qho ( & alpha_0 , omega , geom % freq , dalpha_dyn , & grad_request_t ( dalpha = grad % dalpha , domega = grad % dalpha . or . grad % dC6 ) & ) grad_scs = grad_request_t ( & dcoords = grad % dcoords , & dlattice = grad % dlattice , & dalpha = grad % dalpha . or . grad % dC6 , & dr_vdw = grad % dr_vdw & ) damp_scs = damp damp_scs % version = damping_types ( 1 ) do i_freq = 0 , n_freq alpha_dyn_scs (:, i_freq ) = run_scs ( & geom , alpha_dyn (:, i_freq ), damp_scs , dalpha_dyn_scs (:, i_freq ), grad_scs & ) if ( geom % has_exc ()) return end do C6_scs = C6_from_alpha ( alpha_dyn_scs , geom % freq , dC6_scs_dalpha_dyn_scs , grad % any ()) damp_mbd = damp damp_mbd % r_vdw = scale_with_ratio ( & damp % r_vdw , alpha_dyn_scs (:, 0 ), alpha_dyn (:, 0 ), 1 d0 / 3 , dr_vdw_scs , & grad_request_t ( dV = grad % any (), dV_free = grad % dalpha , dX_free = grad % dr_vdw ) & ) damp_mbd % version = damping_types ( 2 ) res = get_mbd_energy ( geom , alpha_dyn_scs (:, 0 ), C6_scs , damp_mbd , dene_mbd , & grad_request_t ( & dcoords = grad % dcoords , dlattice = grad % dlattice , & dalpha = grad % any (), dC6 = grad % any (), dr_vdw = grad % any () & ) & ) if ( geom % has_exc ()) return if (. not . grad % any ()) return allocate ( freq_w ( 0 : ubound ( geom % freq , 1 ))) freq_w = geom % freq % weight freq_w ( 0 ) = 1 d0 dene_dalpha_scs_dyn (:, 0 ) = dene_mbd % dalpha + dene_mbd % dr_vdw * dr_vdw_scs % dV do i_freq = 1 , n_freq dene_dalpha_scs_dyn (:, i_freq ) = & dene_mbd % dC6 * dC6_scs_dalpha_dyn_scs (:, i_freq ) end do if ( grad % dcoords ) then allocate ( dene % dcoords ( n_atoms , 3 ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dene % dcoords ( geom % idx % j_atom , :) & = dene % dcoords ( geom % idx % j_atom , :) & + freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) & * dalpha_dyn_scs ( my_i_atom , i_freq )% dcoords end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call all_reduce ( dene % dcoords , geom % blacs ) #endif dene % dcoords = dene % dcoords + dene_mbd % dcoords end if if ( grad % dlattice ) then allocate ( dene % dlattice ( 3 , 3 ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) if (. not . any ( i_atom == geom % idx % j_atom )) cycle do i_freq = 0 , n_freq dene % dlattice = dene % dlattice & + freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) & * dalpha_dyn_scs ( my_i_atom , i_freq )% dlattice end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call all_reduce ( dene % dlattice , geom % blacs ) #endif dene % dlattice = dene % dlattice + dene_mbd % dlattice end if if ( grad % dalpha ) then allocate ( dene % dalpha ( n_atoms ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dene % dalpha ( geom % idx % j_atom ) = dene % dalpha ( geom % idx % j_atom ) + & freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) * & dalpha_dyn_scs ( my_i_atom , i_freq )% dalpha * ( & dalpha_dyn ( i_freq )% dalpha ( geom % idx % j_atom ) & + dalpha_dyn ( i_freq )% domega ( geom % idx % j_atom ) & * domega % dalpha ( geom % idx % j_atom ) & ) end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call all_reduce ( dene % dalpha , geom % blacs ) #endif dene % dalpha = dene % dalpha + dene_mbd % dr_vdw * dr_vdw_scs % dV_free end if if ( grad % dC6 ) then allocate ( dene % dC6 ( n_atoms ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dene % dC6 ( geom % idx % j_atom ) = dene % dC6 ( geom % idx % j_atom ) + & freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) * & dalpha_dyn_scs ( my_i_atom , i_freq )% dalpha * & dalpha_dyn ( i_freq )% domega ( geom % idx % j_atom ) & * domega % dC6 ( geom % idx % j_atom ) end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call all_reduce ( dene % dC6 , geom % blacs ) #endif end if if ( grad % dr_vdw ) then allocate ( dene % dr_vdw ( n_atoms ), source = 0 d0 ) do my_i_atom = 1 , size ( dalpha_dyn_scs , 1 ) i_atom = geom % idx % i_atom ( my_i_atom ) do i_freq = 0 , n_freq dene % dr_vdw ( geom % idx % j_atom ) = dene % dr_vdw ( geom % idx % j_atom ) + & freq_w ( i_freq ) * dene_dalpha_scs_dyn ( i_atom , i_freq ) * & dalpha_dyn_scs ( my_i_atom , i_freq )% dr_vdw end do end do #ifdef WITH_SCALAPACK if ( geom % idx % parallel ) call all_reduce ( dene % dr_vdw , geom % blacs ) #endif dene % dr_vdw = dene % dr_vdw + dene_mbd % dr_vdw * dr_vdw_scs % dX_free end if end function real ( dp ) function test_frequency_grid ( freq ) result ( error ) !! Calculate relative quadrature error in C6 of a carbon atom type ( quad_pt_t ), intent ( in ) :: freq (:) real ( dp ) :: alpha ( 1 , 0 : ubound ( freq , 1 )), C6 ( 1 ) type ( grad_t ), allocatable :: dalpha (:) type ( grad_request_t ) :: grad alpha = alpha_dyn_qho ([ 21 d0 ], [ 9 9.5d0 ], freq , dalpha , grad ) C6 = C6_from_alpha ( alpha , freq ) error = abs ( C6 ( 1 ) / 9 9.5d0 - 1 d0 ) end function function make_k_pts ( k_grid , lattice , shift , dkdlattice , grad ) result ( k_pts ) integer , intent ( in ) :: k_grid ( 3 ) real ( dp ), intent ( in ) :: lattice ( 3 , 3 ) real ( dp ), intent ( in ) :: shift real ( dp ), allocatable , intent ( out ) :: dkdlattice (:, :, :, :) logical , intent ( in ) :: grad real ( dp ) :: k_pts ( 3 , k_grid ( 1 ) * k_grid ( 2 ) * k_grid ( 3 )) integer :: n_kpt ( 3 ), i_kpt , i_latt , a real ( dp ) :: n_kpt_shifted ( 3 ), latt_inv ( 3 , 3 ) n_kpt = [ 0 , 0 , - 1 ] do i_kpt = 1 , product ( k_grid ) call shift_idx ( n_kpt , [ 0 , 0 , 0 ], k_grid - 1 ) n_kpt_shifted = dble ( n_kpt ) + shift where ( 2 * n_kpt_shifted > k_grid ) n_kpt_shifted = n_kpt_shifted - dble ( k_grid ) k_pts (:, i_kpt ) = n_kpt_shifted / k_grid end do latt_inv = inverse ( lattice ) k_pts = matmul ( 2 * pi * transpose ( latt_inv ), k_pts ) if ( grad ) then allocate ( dkdlattice ( 3 , product ( k_grid ), 3 , 3 )) forall ( i_kpt = 1 : product ( k_grid ), i_latt = 1 : 3 , a = 1 : 3 ) dkdlattice (:, i_kpt , i_latt , a ) = & - latt_inv ( i_latt , :) * k_pts ( a , i_kpt ) end forall end if end function end module","tags":"","loc":"sourcefile/mbd_methods.f90.html"},{"title":"mbd_formulas.f90 – Libmbd","text":"Contents Modules mbd_formulas Source Code mbd_formulas.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_formulas !! Common formulas used at multiple places. use mbd_constants use mbd_gradients , only : grad_t , grad_request_t use mbd_utils , only : quad_pt_t , tostr implicit none private public :: omega_qho , alpha_dyn_qho , C6_from_alpha , sigma_selfint , scale_with_ratio contains function omega_qho ( C6 , alpha , domega , grad ) result ( omega ) !!  !! \\omega=\\frac{4C_6}{3\\alpha_{0}&#94;2},\\qquad !! \\partial\\omega=\\omega\\left( !! \\frac{\\partial C_6}{C_6}-\\frac{2\\partial\\alpha_0}{\\alpha_0} !! \\right) !!  real ( dp ), intent ( in ) :: C6 (:) real ( dp ), intent ( in ) :: alpha (:) type ( grad_t ), intent ( out ), optional :: domega type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: omega ( size ( C6 )) omega = 4 d0 / 3 * C6 / alpha ** 2 if (. not . present ( grad )) return if ( grad % dC6 ) domega % dC6 = omega / C6 if ( grad % dalpha ) domega % dalpha = - 2 * omega / alpha end function function alpha_dyn_qho ( alpha_0 , omega , freq , dalpha , grad ) result ( alpha ) !!  !! \\alpha(\\mathrm iu)=\\frac{\\alpha_0}{1+u&#94;2/\\omega&#94;2},\\qquad !! \\partial\\alpha(\\mathrm iu)=\\alpha(\\mathrm iu)\\left( !! \\frac{\\partial\\alpha_0}{\\alpha_0}+ !! \\frac2\\omega\\frac{\\partial\\omega}{1+\\omega&#94;2/u&#94;2} !! \\right) !!  real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: omega (:) type ( quad_pt_t ), intent ( in ) :: freq ( 0 :) type ( grad_t ), allocatable , intent ( out ) :: dalpha (:) type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: alpha ( size ( alpha_0 ), 0 : ubound ( freq , 1 )) integer :: i_freq , n_atoms n_atoms = size ( alpha_0 ) allocate ( dalpha ( 0 : ubound ( alpha , 2 ))) do i_freq = 0 , ubound ( alpha , 2 ) associate ( alpha => alpha (:, i_freq ), u => freq ( i_freq )% val ) alpha = alpha_0 / ( 1 + ( u / omega ) ** 2 ) if ( grad % dalpha ) dalpha ( i_freq )% dalpha = alpha / alpha_0 if ( grad % domega ) dalpha ( i_freq )% domega = alpha * 2 d0 / omega / ( 1 d0 + ( omega / u ) ** 2 ) end associate end do end function function C6_from_alpha ( alpha , freq , dC6_dalpha , grad ) result ( C6 ) !!  !! \\bar C_6=\\frac3\\pi\\int_0&#94;\\infty\\mathrm du\\,\\bar\\alpha(u)&#94;2,\\qquad !! \\partial\\bar C_6=\\frac6\\pi\\int_0&#94;\\infty\\mathrm du !! \\bar\\alpha(u)\\partial\\bar\\alpha(u) !!  real ( dp ), intent ( in ) :: alpha (:, 0 :) type ( quad_pt_t ), intent ( in ) :: freq ( 0 :) real ( dp ), allocatable , intent ( out ), optional :: dC6_dalpha (:, :) logical , intent ( in ), optional :: grad real ( dp ) :: C6 ( size ( alpha , 1 )) integer :: i_freq , n_atoms n_atoms = size ( alpha , 1 ) C6 = 0 d0 do i_freq = 0 , ubound ( alpha , 2 ) C6 = C6 + 3 d0 / pi * alpha (:, i_freq ) ** 2 * freq ( i_freq )% weight end do if (. not . present ( grad )) return if (. not . grad ) return allocate ( dC6_dalpha ( n_atoms , 0 : ubound ( alpha , 2 )), source = 0 d0 ) do i_freq = 0 , ubound ( alpha , 2 ) dC6_dalpha (:, i_freq ) = dC6_dalpha (:, i_freq ) + 6 d0 / pi * alpha (:, i_freq ) end do end function function sigma_selfint ( alpha , dsigma_dalpha , grad ) result ( sigma ) !!  !! \\begin{gathered} !! \\sigma_i(u)=\\left(\\frac13\\sqrt{\\frac2\\pi}\\alpha_i(u)\\right)&#94;{\\frac13},\\qquad !! \\partial\\sigma_i=\\sigma_i\\frac{\\partial\\alpha_i}{3\\alpha_i} !! \\\\ \\sigma_{ij}(u)=\\sqrt{\\sigma_i(u)&#94;2+\\sigma_j(u)&#94;2},\\qquad !! \\partial\\sigma_{ij}= !! \\frac{\\sigma_i\\partial\\sigma_i+\\sigma_j\\partial\\sigma_j}{\\sigma_{ij}} !! \\end{gathered} !!  real ( dp ), intent ( in ) :: alpha (:) real ( dp ), allocatable , intent ( out ), optional :: dsigma_dalpha (:) logical , intent ( in ), optional :: grad real ( dp ) :: sigma ( size ( alpha )) sigma = ( sqrt ( 2 d0 / pi ) * alpha / 3 d0 ) ** ( 1 d0 / 3 ) if (. not . present ( grad )) return if ( grad ) dsigma_dalpha = sigma / ( 3 * alpha ) end function function scale_with_ratio ( x , yp , y , q , dx , grad ) result ( xp ) !!  !! x'=x\\left(\\frac{y'}y\\right)&#94;q,\\qquad !! \\partial x'=x\\left( !! \\frac{\\partial x}x+ !! q\\frac{\\partial y'}{y'}- !! q\\frac{\\partial y}{y} !! \\right) !!  real ( dp ), intent ( in ) :: x (:), yp (:), y (:) real ( dp ), intent ( in ) :: q type ( grad_t ), intent ( out ), optional :: dx type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: xp ( size ( x )) xp = x * ( yp / y ) ** q if (. not . present ( grad )) return if ( grad % dX_free ) dx % dX_free = xp / x if ( grad % dV ) dx % dV = xp * q / yp if ( grad % dV_free ) dx % dV_free = - xp * q / y end function end module","tags":"","loc":"sourcefile/mbd_formulas.f90.html"},{"title":"mbd_dipole.F90 – Libmbd","text":"Contents Modules mbd_dipole Source Code mbd_dipole.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef MBD_TYPE module mbd_dipole !! Construction of dipole tensors and dipole matrices. use mbd_constants use mbd_matrix , only : matrix_re_t , matrix_cplx_t use mbd_geom , only : geom_t , supercell_circum use mbd_damping , only : damping_t , damping_fermi , damping_sqrtfermi , & op1minus_grad use mbd_gradients , only : grad_t , grad_matrix_re_t , grad_matrix_cplx_t , & grad_scalar_t , grad_request_t use mbd_lapack , only : eigvals , inverse use mbd_linalg , only : outer use mbd_utils , only : tostr , shift_idx implicit none private public :: dipole_matrix , T_bare , T_erf_coulomb , damping_grad , T_erfc , B_erfc , C_erfc interface dipole_matrix !! Form either a real or a complex dipole matrix. !! !! The real-typed version is equivalent to \\mathbf q=0. !! !!  !! \\boldsymbol{\\mathcal A}:=[\\mathbf a_1\\mathbf a_2\\mathbf !! a_3],\\qquad\\boldsymbol{\\mathcal B}:=[\\mathbf b_1\\mathbf b_2\\mathbf b_3] !! \\\\ \\boldsymbol{\\mathcal B}=2\\pi(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm !! T,\\qquad \\partial\\boldsymbol{\\mathcal B}=-\\big((\\partial\\boldsymbol{\\mathcal !! A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\boldsymbol{\\mathcal B} !! \\\\ \\mathbf R_\\mathbf n=\\boldsymbol{\\mathcal A}\\mathbf !! n,\\qquad\\partial\\mathbf R_\\mathbf n=(\\partial\\boldsymbol{\\mathcal !! A})\\mathbf n, !! \\\\ \\mathbf G_\\mathbf m=\\boldsymbol{\\mathcal B}\\mathbf m,\\qquad !! \\partial\\mathbf G_\\mathbf m=-\\big((\\partial\\boldsymbol{\\mathcal !! A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf G_\\mathbf m, !! \\\\ \\frac{\\partial G_{\\mathbf ma}}{\\partial A_{bc}}=-\\mathcal A&#94;{-1}_{ca}G_{\\mathbf mb} !!  !! !!  !! \\begin{gathered} !! \\mathbf T_{ij}(\\mathbf q)=\\sum_{\\mathbf n}\\mathbf T(\\mathbf R_{\\mathbf !! nij})\\mathrm e&#94;{-\\mathrm i\\mathbf q\\cdot\\mathbf R_{\\mathbf nij}},\\quad\\mathbf !! R_{\\mathbf nij}=\\mathbf R_j+\\mathbf R_\\mathbf n-\\mathbf R_i !! \\\\ \\frac{\\mathrm d\\mathbf R_{\\mathbf nij}}{\\mathrm d\\mathbf !! R_k}=(\\delta_{jk}-\\delta_{ik})\\mathbf I !! \\\\ \\mathbf{T}_{ij}(\\mathbf{q})\\approx\\mathbf{T}&#94;\\text{Ew}_{ij}(\\mathbf{q}) !! =\\sum_\\mathbf n&#94;{|\\mathbf R_{\\mathbf nij}|<R_\\text c}\\mathbf !! T&#94;\\text{erfc}(\\mathbf R_{\\mathbf nij};\\gamma)\\mathrm e&#94;{-\\mathrm i\\mathbf !! q\\cdot\\mathbf R_{\\mathbf nij}} +\\frac{4\\pi}{V_\\text{uc}}\\sum_{\\mathbf !! m}&#94;{0<|\\mathbf k_\\mathbf m|<k_\\text c}\\mathbf{\\hat k}_\\mathbf !! m\\otimes\\mathbf{\\hat k}_\\mathbf m\\,\\mathrm e&#94;{-\\frac{k_\\mathbf !! m&#94;2}{4\\gamma&#94;2}-\\mathrm i\\mathbf G_\\mathbf m\\cdot\\mathbf R_{ij}} !! \\\\ -\\frac{4\\gamma&#94;3}{3\\sqrt\\pi}\\delta_{ij}\\mathbf I +\\delta(\\mathbf q)\\frac{4 !! \\pi}{3 V_\\text{uc}}\\mathbf I,\\qquad \\mathbf k_\\mathbf m=\\mathbf G_\\mathbf !! m+\\mathbf q !! \\end{gathered} !!  !! !! !!  !! \\partial\\left(\\frac{4\\pi}{V_\\text{uc}}\\right)=-\\frac{4\\pi}{V_\\text{uc}}\\frac{\\partial !! V_\\text{uc}}{V_\\text{uc}},\\qquad\\frac{\\partial !! V_\\text{uc}}{\\partial\\boldsymbol{\\mathcal !! A}}=V_\\text{uc}(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm T !! \\\\ \\partial(k&#94;2)=2\\mathbf k\\cdot\\partial\\mathbf k !! \\\\ \\mathbf{\\hat k}\\otimes\\partial\\mathbf{\\hat k}=\\frac{\\mathbf !! k\\otimes\\partial\\mathbf k}{k&#94;2}-\\frac{\\mathbf k\\otimes\\mathbf !! k}{2k&#94;4}\\partial(k&#94;2) !!  !! !!  !! \\gamma:=\\frac{2.5}{\\sqrt[3]{V_\\text{uc}}},\\quad R_\\text !! c:=\\frac6\\gamma,\\quad k_\\text c:=10\\gamma !!  module procedure dipole_matrix_real module procedure dipole_matrix_complex end interface contains #   define MBD_TYPE 0 #endif #if MBD_TYPE == 0 type ( matrix_re_t ) function dipole_matrix_real ( & geom , damp , ddipmat , grad ) result ( dipmat ) use mbd_constants , only : ZERO => ZERO_REAL #elif MBD_TYPE == 1 type ( matrix_cplx_t ) function dipole_matrix_complex ( & geom , damp , ddipmat , grad , q ) result ( dipmat ) use mbd_constants , only : ZERO => ZERO_COMPLEX #endif type ( geom_t ), intent ( inout ) :: geom type ( damping_t ), intent ( in ) :: damp type ( grad_request_t ), intent ( in ), optional :: grad #if MBD_TYPE == 0 type ( grad_matrix_re_t ), intent ( out ), optional :: ddipmat #elif MBD_TYPE == 1 type ( grad_matrix_cplx_t ), intent ( out ), optional :: ddipmat real ( dp ), intent ( in ) :: q ( 3 ) #endif real ( dp ) :: Rn ( 3 ), Rnij ( 3 ), Rnij_norm , T ( 3 , 3 ), f_damp , & sigma_ij , T0 ( 3 , 3 ), beta_R_vdw integer :: i_atom , j_atom , i_cell , n ( 3 ), range_n ( 3 ), i , j , & n_atoms , my_i_atom , my_j_atom , i_latt logical :: do_ewald , is_periodic type ( grad_matrix_re_t ) :: dT , dT0 , dTew type ( grad_scalar_t ) :: df type ( grad_request_t ) :: grad_ij #if MBD_TYPE == 0 real ( dp ) :: Tij ( 3 , 3 ) type ( grad_matrix_re_t ) :: dTij #elif MBD_TYPE == 1 complex ( dp ) :: Tij ( 3 , 3 ), exp_qR type ( grad_matrix_cplx_t ) :: dTij #endif do_ewald = . false . is_periodic = allocated ( geom % lattice ) n_atoms = geom % siz () if ( present ( grad )) then grad_ij = grad grad_ij % dcoords = grad % dcoords . or . grad % dlattice end if #ifdef WITH_SCALAPACK call dipmat % init ( geom % idx , geom % blacs ) #else call dipmat % init ( geom % idx ) #endif if ( is_periodic ) then do_ewald = geom % gamm > 0 d0 range_n = supercell_circum ( geom % lattice , geom % real_space_cutoff ) else range_n (:) = 0 end if if ( grad_ij % dcoords ) allocate ( dTij % dr ( 3 , 3 , 3 )) associate ( my_nr => size ( dipmat % idx % i_atom ), my_nc => size ( dipmat % idx % j_atom )) allocate ( dipmat % val ( 3 * my_nr , 3 * my_nc ), source = ZERO ) if ( present ( grad )) then if ( grad % dcoords ) allocate ( ddipmat % dr ( 3 * my_nr , 3 * my_nc , 3 ), source = ZERO ) if ( grad % dlattice ) then allocate ( ddipmat % dlattice ( 3 * my_nr , 3 * my_nc , 3 , 3 ), source = ZERO ) end if if ( grad % dr_vdw ) then allocate ( ddipmat % dvdw ( 3 * my_nr , 3 * my_nc ), source = ZERO ) allocate ( dTij % dvdw ( 3 , 3 )) end if if ( grad % dsigma ) then allocate ( ddipmat % dsigma ( 3 * my_nr , 3 * my_nc ), source = ZERO ) allocate ( dTij % dsigma ( 3 , 3 )) end if #if MBD_TYPE == 1 if ( grad % dq ) then allocate ( ddipmat % dq ( 3 * my_nr , 3 * my_nc , 3 ), source = ZERO ) allocate ( dTij % dq ( 3 , 3 , 3 )) end if #endif end if end associate call geom % clock ( 11 ) n = [ 0 , 0 , - 1 ] each_cell : do i_cell = 1 , product ( 1 + 2 * range_n ) call shift_idx ( n , - range_n , range_n ) if ( is_periodic ) then Rn = matmul ( geom % lattice , n ) else Rn (:) = 0 d0 end if each_atom : do my_i_atom = 1 , size ( dipmat % idx % i_atom ) i_atom = dipmat % idx % i_atom ( my_i_atom ) each_atom_pair : do my_j_atom = 1 , size ( dipmat % idx % j_atom ) j_atom = dipmat % idx % j_atom ( my_j_atom ) if ( i_cell == 1 ) then if ( i_atom == j_atom ) cycle end if Rnij = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) - Rn Rnij_norm = sqrt ( sum ( Rnij ** 2 )) if ( is_periodic . and . Rnij_norm > geom % real_space_cutoff ) cycle if ( allocated ( damp % R_vdw )) then beta_R_vdw = damp % beta * sum ( damp % R_vdw ([ i_atom , j_atom ])) end if if ( allocated ( damp % sigma )) then sigma_ij = damp % mayer_scaling & * sqrt ( sum ( damp % sigma ([ i_atom , j_atom ]) ** 2 )) end if select case ( damp % version ) case ( \"bare\" ) T = T_bare ( Rnij , dT , grad_ij % dcoords ) case ( \"dip,1mexp\" ) T = T_1mexp_coulomb ( Rnij , beta_R_vdw , damp % a ) case ( \"fermi,dip\" ) f_damp = damping_fermi ( Rnij , beta_R_vdw , damp % a , df , grad_ij ) T0 = T_bare ( Rnij , dT0 , grad_ij % dcoords ) T = damping_grad ( f_damp , df , T0 , dT0 , dT , grad_ij ) case ( \"sqrtfermi,dip\" ) T = damping_sqrtfermi ( Rnij , beta_R_vdw , damp % a ) * T_bare ( Rnij ) case ( \"custom,dip\" ) T = damp % damping_custom ( i_atom , j_atom ) * T_bare ( Rnij ) case ( \"dip,custom\" ) T = damp % potential_custom (:, :, i_atom , j_atom ) case ( \"dip,gg\" ) T = T_erf_coulomb ( Rnij , sigma_ij , dT , grad_ij ) case ( \"fermi,dip,gg\" ) f_damp = damping_fermi ( Rnij , beta_R_vdw , damp % a , df , grad_ij ) call op1minus_grad ( f_damp , df ) T0 = T_erf_coulomb ( Rnij , sigma_ij , dT0 , grad_ij ) T = damping_grad ( f_damp , df , T0 , dT0 , dT , grad_ij ) do_ewald = . false . case ( \"sqrtfermi,dip,gg\" ) T = ( 1 d0 - damping_sqrtfermi ( Rnij , beta_R_vdw , damp % a )) * & T_erf_coulomb ( Rnij , sigma_ij ) do_ewald = . false . case ( \"custom,dip,gg\" ) T = ( 1 d0 - damp % damping_custom ( i_atom , j_atom )) * & T_erf_coulomb ( Rnij , sigma_ij ) do_ewald = . false . end select if ( grad_ij % dr_vdw ) dT % dvdw = damp % beta * dT % dvdw if ( do_ewald ) then T = T & + T_erfc ( Rnij , geom % gamm , dTew , grad_ij ) & - T_bare ( Rnij , dT0 , grad_ij % dcoords ) if ( grad_ij % dcoords ) dT % dr = dT % dr + dTew % dr - dT0 % dr end if Tij = T if ( grad_ij % dcoords ) dTij % dr = dT % dr if ( grad_ij % dr_vdw ) dTij % dvdw = dT % dvdw if ( grad_ij % dsigma ) dTij % dsigma = dT % dsigma #if MBD_TYPE == 1 exp_qR = exp ( - IMI * ( dot_product ( q , Rnij ))) Tij = T * exp_qR if ( grad_ij % dcoords ) then forall ( i = 1 : 3 ) dTij % dr (:, :, i ) = dT % dr (:, :, i ) * exp_qR - IMI * q ( i ) * Tij end forall end if if ( grad_ij % dsigma ) dTij % dsigma = dT % dsigma * exp_qR if ( grad_ij % dr_vdw ) dTij % dvdw = dT % dvdw * exp_qR if ( grad_ij % dq ) then forall ( i = 1 : 3 ) dTij % dq (:, :, i ) = - IMI * Rnij ( i ) * Tij end forall end if #endif i = 3 * ( my_i_atom - 1 ) j = 3 * ( my_j_atom - 1 ) associate ( T_sub => dipmat % val ( i + 1 : i + 3 , j + 1 : j + 3 )) T_sub = T_sub + Tij end associate if (. not . present ( grad )) cycle if ( grad % dcoords . and . i_atom /= j_atom ) then associate ( dTdR_sub => ddipmat % dr ( i + 1 : i + 3 , j + 1 : j + 3 , :)) dTdR_sub = dTdR_sub + dTij % dr end associate end if if ( grad % dlattice ) then do i_latt = 1 , 3 associate ( & dTda_sub => ddipmat % dlattice ( i + 1 : i + 3 , j + 1 : j + 3 , i_latt , :) & ) dTda_sub = dTda_sub - dTij % dr * ( n ( i_latt )) end associate end do end if if ( grad % dr_vdw ) then associate ( dTdRvdw_sub => ddipmat % dvdw ( i + 1 : i + 3 , j + 1 : j + 3 )) dTdRvdw_sub = dTdRvdw_sub + dTij % dvdw end associate end if if ( grad % dsigma ) then associate ( dTdsigma_sub => ddipmat % dsigma ( i + 1 : i + 3 , j + 1 : j + 3 )) dTdsigma_sub = dTdsigma_sub + dTij % dsigma end associate end if #if MBD_TYPE == 1 if ( grad % dq ) then associate ( dTdq_sub => ddipmat % dq ( i + 1 : i + 3 , j + 1 : j + 3 , :)) dTdq_sub = dTdq_sub + dTij % dq end associate end if #endif end do each_atom_pair end do each_atom end do each_cell call geom % clock ( - 11 ) if ( do_ewald ) then #if MBD_TYPE == 0 call add_ewald_dipole_parts_real ( geom , dipmat , ddipmat , grad ) #elif MBD_TYPE == 1 call add_ewald_dipole_parts_complex ( geom , dipmat , ddipmat , grad , q ) #endif end if end function #if MBD_TYPE == 0 subroutine add_ewald_dipole_parts_real ( geom , dipmat , ddipmat , grad ) type ( matrix_re_t ), intent ( inout ) :: dipmat type ( grad_matrix_re_t ), intent ( inout ) :: ddipmat #elif MBD_TYPE == 1 subroutine add_ewald_dipole_parts_complex ( geom , dipmat , ddipmat , grad , q ) type ( matrix_cplx_t ), intent ( inout ) :: dipmat type ( grad_matrix_cplx_t ), intent ( inout ) :: ddipmat #endif type ( geom_t ), intent ( inout ) :: geom type ( grad_request_t ), intent ( in ), optional :: grad #if MBD_TYPE == 1 real ( dp ), intent ( in ) :: q ( 3 ) #endif logical :: do_surface real ( dp ) :: rec_latt ( 3 , 3 ), volume , G ( 3 ), Rij ( 3 ), k ( 3 ), & k_sq , G_Rij , latt_inv ( 3 , 3 ), & dGdA ( 3 ), dk_sqdA , dkk_dA ( 3 , 3 ), vol_prefactor , & k_otimes_k ( 3 , 3 ), exp_k_sq_gamma , vol_kk_exp_ksq ( 3 , 3 ) integer :: & i_atom , j_atom , i , j , i_xyz , m ( 3 ), i_m , & range_m ( 3 ), my_i_atom , my_j_atom , i_latt , a , b #if MBD_TYPE == 0 real ( dp ) :: Tij ( 3 , 3 ), exp_GR , vol_exp #elif MBD_TYPE == 1 complex ( dp ) :: Tij ( 3 , 3 ), exp_GR , vol_exp integer :: c real ( dp ) :: dkk_dq ( 3 , 3 , 3 ) #endif latt_inv = inverse ( geom % lattice ) rec_latt = 2 * pi * transpose ( latt_inv ) volume = abs ( dble ( product ( eigvals ( geom % lattice )))) vol_prefactor = 4 * pi / volume range_m = supercell_circum ( rec_latt , geom % rec_space_cutoff ) call geom % clock ( 12 ) m = [ 0 , 0 , - 1 ] each_recip_vec : do i_m = 1 , product ( 1 + 2 * range_m ) call shift_idx ( m , - range_m , range_m ) G = matmul ( rec_latt , m ) #if MBD_TYPE == 1 k = G + q #elif MBD_TYPE == 0 k = G #endif k_sq = sum ( k ** 2 ) if ( sqrt ( k_sq ) > geom % rec_space_cutoff . or . sqrt ( k_sq ) < 1 d - 15 ) cycle exp_k_sq_gamma = exp ( - k_sq / ( 4 * geom % gamm ** 2 )) forall ( a = 1 : 3 , b = 1 : 3 ) k_otimes_k ( a , b ) = k ( a ) * k ( b ) / k_sq each_atom : do my_i_atom = 1 , size ( dipmat % idx % i_atom ) i_atom = dipmat % idx % i_atom ( my_i_atom ) each_atom_pair : do my_j_atom = 1 , size ( dipmat % idx % j_atom ) j_atom = dipmat % idx % j_atom ( my_j_atom ) Rij = geom % coords (:, i_atom ) - geom % coords (:, j_atom ) G_Rij = dot_product ( G , Rij ) #if MBD_TYPE == 1 exp_GR = exp ( IMI * G_Rij ) #elif MBD_TYPE == 0 exp_GR = cos ( G_Rij ) #endif vol_kk_exp_ksq = vol_prefactor * k_otimes_k * exp_k_sq_gamma Tij = vol_kk_exp_ksq * exp_GR i = 3 * ( my_i_atom - 1 ) j = 3 * ( my_j_atom - 1 ) associate ( T_sub => dipmat % val ( i + 1 : i + 3 , j + 1 : j + 3 )) T_sub = T_sub + Tij end associate if (. not . present ( grad )) cycle vol_exp = vol_prefactor * exp_k_sq_gamma * exp_GR if ( grad % dcoords . and . i_atom /= j_atom ) then associate ( dTdR_sub => ddipmat % dr ( i + 1 : i + 3 , j + 1 : j + 3 , :)) forall ( i_xyz = 1 : 3 ) dTdR_sub (:, :, i_xyz ) = dTdR_sub (:, :, i_xyz ) & #if MBD_TYPE == 1 + Tij * IMI * G ( i_xyz ) #elif MBD_TYPE == 0 - vol_kk_exp_ksq * sin ( G_Rij ) * G ( i_xyz ) #endif end forall end associate end if if ( grad % dlattice ) then do i_latt = 1 , 3 do i_xyz = 1 , 3 dGdA = - latt_inv ( i_latt , :) * G ( i_xyz ) dk_sqdA = 2 * dot_product ( k , dGdA ) forall ( a = 1 : 3 , b = 1 : 3 ) dkk_dA ( a , b ) = k ( a ) * dGdA ( b ) / k_sq & - k ( a ) * k ( b ) * dk_sqdA / ( 2 * k_sq ** 2 ) end forall dkk_dA = dkk_dA + transpose ( dkk_dA ) associate ( & dTda_sub => ddipmat % dlattice ( i + 1 : i + 3 , j + 1 : j + 3 , i_latt , i_xyz ) & ) dTda_sub = dTda_sub & - Tij * latt_inv ( i_latt , i_xyz ) & + vol_exp * dkk_dA & - Tij * dk_sqdA / ( 4 * geom % gamm ** 2 ) & #if MBD_TYPE == 1 + Tij * IMI * dot_product ( dGdA , Rij ) #elif MBD_TYPE == 0 - vol_kk_exp_ksq * sin ( G_Rij ) * dot_product ( dGdA , Rij ) #endif end associate end do end do end if #if MBD_TYPE == 1 if ( grad % dq ) then forall ( b = 1 : 3 , a = 1 : 3 ) forall ( c = 1 : 3 ) dkk_dq ( b , c , a ) = - 2 * k ( a ) * k ( b ) * k ( c ) / k_sq ** 2 dkk_dq ( b , a , a ) = dkk_dq ( b , a , a ) + k ( b ) / k_sq dkk_dq ( a , b , a ) = dkk_dq ( a , b , a ) + k ( b ) / k_sq end forall associate ( dTdq_sub => ddipmat % dq ( i + 1 : i + 3 , j + 1 : j + 3 , :)) dTdq_sub = dTdq_sub + vol_exp * dkk_dq forall ( a = 1 : 3 ) dTdq_sub (:, :, a ) = dTdq_sub (:, :, a ) & - Tij * k ( a ) / ( 2 * geom % gamm ** 2 ) end forall end associate end if #endif end do each_atom_pair end do each_atom end do each_recip_vec ! self energy call dipmat % add_diag_scalar ( - 4 * geom % gamm ** 3 / ( 3 * sqrt ( pi ))) ! surface term #if MBD_TYPE == 1 do_surface = sqrt ( sum ( q ** 2 )) < 1 d - 15 #else do_surface = . true . #endif if ( do_surface ) then do my_i_atom = 1 , size ( dipmat % idx % i_atom ) do my_j_atom = 1 , size ( dipmat % idx % j_atom ) do i_xyz = 1 , 3 i = 3 * ( my_i_atom - 1 ) + i_xyz j = 3 * ( my_j_atom - 1 ) + i_xyz dipmat % val ( i , j ) = dipmat % val ( i , j ) + vol_prefactor / 3 if (. not . present ( grad )) cycle if ( grad % dlattice ) then ddipmat % dlattice ( i , j , :, :) = ddipmat % dlattice ( i , j , :, :) & - vol_prefactor / 3 * latt_inv end if end do end do end do end if call geom % clock ( - 12 ) end subroutine #if MBD_TYPE == 0 #   undef MBD_TYPE #   define MBD_TYPE 1 #   include \"mbd_dipole.F90\" function T_bare ( r , dT , grad ) result ( T ) !!  !! T_{ab}(\\mathbf r)=\\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac1r= !! \\frac{-3r_ar_b+r&#94;2\\delta_{ab}}{r&#94;5},\\qquad !! \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}=-3\\left( !! \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}+r_c\\delta_{ab}}{r&#94;5}- !! \\frac{5r_ar_br_c}{r&#94;7} !! \\right) !!  real ( dp ), intent ( in ) :: r ( 3 ) type ( grad_matrix_re_t ), intent ( out ), optional :: dT logical , intent ( in ), optional :: grad real ( dp ) :: T ( 3 , 3 ) integer :: a , b , c real ( dp ) :: r_1 , r_2 , r_5 , r_7 r_2 = sum ( r ** 2 ) r_1 = sqrt ( r_2 ) r_5 = r_1 ** 5 forall ( a = 1 : 3 ) T ( a , a ) = ( - 3 * r ( a ) ** 2 + r_2 ) / r_5 forall ( b = a + 1 : 3 ) T ( a , b ) = - 3 * r ( a ) * r ( b ) / r_5 T ( b , a ) = T ( a , b ) end forall end forall if (. not . present ( grad )) return if (. not . grad ) return allocate ( dT % dr ( 3 , 3 , 3 )) r_7 = r_1 ** 7 forall ( a = 1 : 3 ) dT % dr ( a , a , a ) = - 3 * ( 3 * r ( a ) / r_5 - 5 * r ( a ) ** 3 / r_7 ) forall ( b = a + 1 : 3 ) dT % dr ( a , a , b ) = - 3 * ( r ( b ) / r_5 - 5 * r ( a ) ** 2 * r ( b ) / r_7 ) dT % dr ( a , b , a ) = dT % dr ( a , a , b ) dT % dr ( b , a , a ) = dT % dr ( a , a , b ) dT % dr ( b , b , a ) = - 3 * ( r ( a ) / r_5 - 5 * r ( b ) ** 2 * r ( a ) / r_7 ) dT % dr ( b , a , b ) = dT % dr ( b , b , a ) dT % dr ( a , b , b ) = dT % dr ( b , b , a ) forall ( c = b + 1 : 3 ) dT % dr ( a , b , c ) = 15 * r ( a ) * r ( b ) * r ( c ) / r_7 dT % dr ( a , c , b ) = dT % dr ( a , b , c ) dT % dr ( b , a , c ) = dT % dr ( a , b , c ) dT % dr ( b , c , a ) = dT % dr ( a , b , c ) dT % dr ( c , a , b ) = dT % dr ( a , b , c ) dT % dr ( c , b , a ) = dT % dr ( a , b , c ) end forall end forall end forall end function real ( dp ) function B_erfc ( r , gamm , dB , grad ) result ( B ) !!  !! \\begin{aligned} !! B(R,\\gamma) !! &=\\operatorname{erfc}(\\gamma R) !! +\\frac{2\\gamma R}{\\sqrt\\pi}\\mathrm e&#94;{-(\\gamma R)&#94;2} !! \\\\ \\partial B(R,\\gamma) !! &=-\\frac4{\\sqrt\\pi}(\\gamma R)&#94;2\\mathrm e&#94;{-(\\gamma R)&#94;2} !! (R\\partial\\gamma+\\gamma\\partial R) !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r real ( dp ), intent ( in ) :: gamm type ( grad_scalar_t ), intent ( out ), optional :: dB type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: tmp , gamma_r_sq gamma_r_sq = ( gamm * r ) ** 2 B = ( erfc ( gamm * r ) + ( 2 * gamm * r / sqrt ( pi )) * exp ( - gamma_r_sq )) if (. not . present ( grad )) return tmp = - 4 d0 / sqrt ( pi ) * gamma_r_sq * exp ( - gamma_r_sq ) if ( grad % dcoords ) dB % dr_1 = tmp * gamm if ( grad % dgamma ) dB % dgamma = tmp * r end function real ( dp ) function C_erfc ( r , gamm , dC , grad ) result ( C ) !!  !! \\begin{aligned} !! C(r,\\gamma) !! &=3\\operatorname{erfc}(\\gamma R) !! +\\frac{2\\gamma R}{\\sqrt\\pi}(3+2(\\gamma R)&#94;2)\\mathrm e&#94;{-(\\gamma R)&#94;2} !! \\\\ \\partial C(R,\\gamma) !! &=-\\frac8{\\sqrt\\pi}(\\gamma R)&#94;4\\mathrm e&#94;{-(\\gamma R)&#94;2} !! (R\\partial\\gamma+\\gamma\\partial R) !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r real ( dp ), intent ( in ) :: gamm type ( grad_scalar_t ), intent ( out ), optional :: dC type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: tmp , gamma_r_sq gamma_r_sq = ( gamm * r ) ** 2 C = ( 3 * erfc ( gamm * r ) + ( 2 * gamm * r / sqrt ( pi )) * ( 3 d0 + 2 * gamma_r_sq ) * exp ( - gamma_r_sq )) if (. not . present ( grad )) return tmp = - 8 d0 / sqrt ( pi ) * gamma_r_sq ** 2 * exp ( - gamma_r_sq ) if ( grad % dcoords ) dC % dr_1 = tmp * gamm if ( grad % dgamma ) dC % dgamma = tmp * r end function function T_erfc ( r , gamm , dT , grad ) result ( T ) !!  !! T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma) !! =-3\\frac{r_ar_b}{r&#94;5}C(r,\\gamma)+\\frac{\\delta_{ab}}{r&#94;3}B(r,\\gamma) !!  !! !!  !! \\begin{aligned} !! \\frac{\\partial T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma)}{\\partial r_c} !! &=-\\left( !! \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}}{r&#94;5}- !! 5\\frac{r_ar_br_c}{r&#94;7} !! \\right)C(r,\\gamma)-3\\frac{r_c\\delta_{ab}}{r&#94;5}B(r,\\gamma) !! \\\\ &-\\frac{r_ar_br_c}{r&#94;6}\\frac{\\partial C(r,\\gamma)}{\\partial !! r}+\\frac{r_c\\delta_{ab}}{r&#94;4}\\frac{\\partial B(r,\\gamma)}{\\partial r} !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: gamm type ( grad_matrix_re_t ), intent ( out ), optional :: dT type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: T ( 3 , 3 ) integer :: a , b , c real ( dp ) :: r_1 , r_2 , r_3 , r_4 , r_5 , r_6 , r_7 , B_ew , C_ew type ( grad_scalar_t ) :: dB , dC r_2 = sum ( r ** 2 ) r_1 = sqrt ( r_2 ) r_3 = r_1 * r_2 r_5 = r_3 * r_2 B_ew = B_erfc ( r_1 , gamm , dB , grad ) C_ew = C_erfc ( r_1 , gamm , dC , grad ) forall ( a = 1 : 3 ) T ( a , a ) = - C_ew * r ( a ) ** 2 / r_5 + B_ew / r_3 forall ( b = a + 1 : 3 ) T ( a , b ) = - C_ew * r ( a ) * r ( b ) / r_5 T ( b , a ) = T ( a , b ) end forall end forall if (. not . present ( grad )) return if ( grad % dcoords ) then allocate ( dT % dr ( 3 , 3 , 3 )) r_7 = r_1 ** 7 r_4 = r_2 ** 2 r_6 = r_4 * r_2 forall ( c = 1 : 3 ) dT % dr ( c , c , c ) = & - ( 2 * r ( c ) / r_5 - 5 * r ( c ) ** 3 / r_7 ) * C_ew - 3 * r ( c ) / r_5 * B_ew & - r ( c ) ** 3 / r_6 * dC % dr_1 + r ( c ) / r_4 * dB % dr_1 forall ( a = 1 : 3 , a /= c ) dT % dr ( a , c , c ) = & - ( r ( a ) / r_5 - 5 * r ( a ) * r ( c ) ** 2 / r_7 ) * C_ew & - r ( a ) * r ( c ) ** 2 / r_6 * dC % dr_1 dT % dr ( c , a , c ) = dT % dr ( a , c , c ) dT % dr ( a , a , c ) = & 5 * r ( a ) ** 2 * r ( c ) / r_7 * C_ew - 3 * r ( c ) / r_5 * B_ew & - r ( a ) ** 2 * r ( c ) / r_6 * dC % dr_1 + r ( c ) / r_4 * dB % dr_1 forall ( b = a + 1 : 3 , b /= c ) dT % dr ( a , b , c ) = & 5 * r ( a ) * r ( b ) * r ( c ) / r_7 * C_ew - r ( a ) * r ( b ) * r ( c ) / r_6 * dC % dr_1 dT % dr ( b , a , c ) = dT % dr ( a , b , c ) end forall end forall end forall end if if ( grad % dgamma ) then allocate ( dT % dgamma ( 3 , 3 )) forall ( a = 1 : 3 ) dT % dgamma ( a , a ) = - dC % dgamma * r ( a ) ** 2 / r_5 + dB % dgamma / r_3 forall ( b = a + 1 : 3 ) dT % dgamma ( a , b ) = - dC % dgamma * r ( a ) * r ( b ) / r_5 dT % dgamma ( b , a ) = dT % dgamma ( a , b ) end forall end forall end if end function function T_erf_coulomb ( r , sigma , dT , grad ) result ( T ) !!  !! \\begin{aligned} !! T&#94;\\text{GG}_{ab}(\\mathbf r,\\sigma)&= !! \\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac{\\operatorname{erf}(\\zeta)}r= !! \\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big)T_{ab}(\\mathbf r)+ !! 2\\zeta&#94;2\\Theta(\\zeta)\\frac{r_ar_b}{r&#94;5} !! \\\\ \\Theta(\\zeta)&=\\frac{2\\zeta}{\\sqrt\\pi}\\exp(-\\zeta&#94;2),\\qquad !! \\zeta=\\frac r\\sigma !! \\\\ \\frac{\\mathrm d T_{ab}&#94;\\text{GG}(\\mathbf r,\\sigma)}{\\mathrm dr_c}&= !! 2\\zeta\\Theta(\\zeta)\\left(T_{ab}(\\mathbf r)+(3-2\\zeta&#94;2)\\frac{r_ar_b}{r&#94;5}\\right) !! \\frac{\\mathrm d\\zeta}{\\mathrm dr_c} !! \\\\ &+\\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big) !! \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}- !! 2\\zeta&#94;2\\Theta(\\zeta)\\left( !! \\frac13\\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}+ !! \\frac{r_c\\delta_{ab}}{r&#94;5} !! \\right) !! \\\\ \\qquad\\frac{\\mathrm d\\zeta}{\\mathrm dr_c}&= !! \\frac{r_c}{r\\sigma}-\\frac r{\\sigma&#94;2}\\frac{\\mathrm d\\sigma}{\\mathrm dr_c} !! \\end{aligned} !!  real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: sigma type ( grad_matrix_re_t ), intent ( out ), optional :: dT type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: T ( 3 , 3 ) real ( dp ) :: theta , erf_theta , r_5 , r_1 , zeta , bare ( 3 , 3 ) type ( grad_matrix_re_t ) :: dbare real ( dp ) :: tmp33 ( 3 , 3 ), tmp333 ( 3 , 3 , 3 ), rr_r5 ( 3 , 3 ) integer :: a , c bare = T_bare ( r , dbare , grad % dcoords ) r_1 = sqrt ( sum ( r ** 2 )) r_5 = r_1 ** 5 rr_r5 = outer ( r , r ) / r_5 zeta = r_1 / sigma theta = 2 * zeta / sqrt ( pi ) * exp ( - zeta ** 2 ) erf_theta = erf ( zeta ) - theta T = erf_theta * bare + 2 * ( zeta ** 2 ) * theta * rr_r5 if (. not . present ( grad )) return tmp33 = 2 * zeta * theta * ( bare + ( 3 - 2 * zeta ** 2 ) * rr_r5 ) if ( grad % dcoords ) then allocate ( dT % dr ( 3 , 3 , 3 )) forall ( c = 1 : 3 ) dT % dr (:, :, c ) = tmp33 * r ( c ) / ( r_1 * sigma ) tmp333 = dbare % dr / 3 forall ( a = 1 : 3 , c = 1 : 3 ) tmp333 ( a , a , c ) = tmp333 ( a , a , c ) + r ( c ) / r_5 dT % dr = dT % dr + erf_theta * dbare % dr - 2 * ( zeta ** 2 ) * theta * tmp333 end if if ( grad % dsigma ) dT % dsigma = - tmp33 * r_1 / sigma ** 2 end function function T_1mexp_coulomb ( rxyz , sigma , a ) result ( T ) real ( dp ), intent ( in ) :: rxyz ( 3 ), sigma , a real ( dp ) :: T ( 3 , 3 ) real ( dp ) :: r_sigma , zeta_1 , zeta_2 r_sigma = ( sqrt ( sum ( rxyz ** 2 )) / sigma ) ** a zeta_1 = 1 d0 - exp ( - r_sigma ) - a * r_sigma * exp ( - r_sigma ) zeta_2 = - r_sigma * a * exp ( - r_sigma ) * ( 1 + a * ( - 1 + r_sigma )) T = zeta_1 * T_bare ( rxyz ) - zeta_2 * outer ( rxyz , rxyz ) / sqrt ( sum ( rxyz ** 2 )) ** 5 end function function damping_grad ( f , df , T , dT , dfT , grad ) result ( fT ) real ( dp ), intent ( in ) :: f type ( grad_scalar_t ), intent ( in ) :: df real ( dp ), intent ( in ) :: T ( 3 , 3 ) type ( grad_matrix_re_t ), intent ( in ) :: dT type ( grad_matrix_re_t ), intent ( out ) :: dfT type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: fT ( 3 , 3 ) integer :: c fT = f * T if ( grad % dcoords ) then allocate ( dfT % dr ( 3 , 3 , 3 ), source = 0 d0 ) if ( allocated ( df % dr )) forall ( c = 1 : 3 ) dfT % dr (:, :, c ) = df % dr ( c ) * T if ( allocated ( dT % dr )) dfT % dr = dfT % dr + f * dT % dr end if if ( grad % dr_vdw ) then allocate ( dfT % dvdw ( 3 , 3 ), source = 0 d0 ) if ( allocated ( df % dvdw )) dfT % dvdw = df % dvdw * T if ( allocated ( dT % dvdw )) dfT % dvdw = dfT % dvdw + f * dT % dvdw end if if ( grad % dsigma ) dfT % dsigma = f * dT % dsigma end function end module #endif","tags":"","loc":"sourcefile/mbd_dipole.f90.html"},{"title":"mbd_utils.F90 – Libmbd","text":"Contents Modules mbd_utils Source Code mbd_utils.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_utils !! Utility types, interfaces, and procedures. use mbd_constants #ifdef WITH_MPI use mbd_mpi #endif implicit none private public :: tostr , diff3 , diff5 , print_matrix , lower , diff7 , findval , shift_idx , is_true interface tostr module procedure tostr_int module procedure tostr_real end interface interface findval module procedure findval_int end interface type , public :: exception_t !! Represents an exception. integer :: code = 0 character ( 50 ) :: origin = '(unknown)' character ( 150 ) :: msg = '' end type type , public :: result_t !! Stores results from an MBD calculation real ( dp ) :: energy real ( dp ), allocatable :: mode_eigs (:) real ( dp ), allocatable :: modes (:, :) real ( dp ), allocatable :: rpa_orders (:) real ( dp ), allocatable :: mode_eigs_k (:, :) complex ( dp ), allocatable :: modes_k (:, :, :) complex ( dp ), allocatable :: modes_k_single (:, :) real ( dp ), allocatable :: rpa_orders_k (:, :) end type type , public :: atom_index_t !! Maps from atom indexes to positions in matrices. integer , allocatable :: i_atom (:) integer , allocatable :: j_atom (:) integer :: n_atoms #   ifdef WITH_SCALAPACK logical :: parallel #   endif end type type , public :: clock_t !! Used for measuring performance. logical :: active = . true . integer , allocatable :: timestamps (:), counts (:) contains procedure :: init => clock_init procedure :: clock => clock_clock end type type , public :: quad_pt_t !! Represents a 1D quadrature point real ( dp ) :: val real ( dp ) :: weight end type contains character ( len = 50 ) elemental function tostr_int ( k , format ) result ( s ) integer , intent ( in ) :: k character ( len =* ), intent ( in ), optional :: format if ( present ( format )) then write ( s , format ) k else write ( s , \"(i20)\" ) k end if s = adjustl ( s ) end function character ( len = 50 ) elemental function tostr_real ( x , format ) result ( s ) real ( dp ), intent ( in ) :: x character ( * ), intent ( in ), optional :: format if ( present ( format )) then write ( s , format ) x else write ( s , \"(g50.17e3)\" ) x end if s = adjustl ( s ) end function real ( dp ) pure function diff3 ( x , delta ) real ( dp ), intent ( in ) :: x ( - 1 :) real ( dp ), intent ( in ) :: delta diff3 = ( x ( 1 ) - x ( - 1 )) / ( 2 * delta ) end function real ( dp ) pure function diff5 ( x , delta ) real ( dp ), intent ( in ) :: x ( - 2 :) real ( dp ), intent ( in ) :: delta diff5 = ( 1.d0 / 12 * x ( - 2 ) - 2.d0 / 3 * x ( - 1 ) + 2.d0 / 3 * x ( 1 ) - 1.d0 / 12 * x ( 2 )) / delta end function real ( dp ) pure function diff7 ( x , delta ) real ( dp ), intent ( in ) :: x ( - 3 :) real ( dp ), intent ( in ) :: delta diff7 = ( & - 1.d0 / 60 * x ( - 3 ) & + 3.d0 / 20 * x ( - 2 ) & - 3.d0 / 4 * x ( - 1 ) & + 3.d0 / 4 * x ( 1 ) & - 3.d0 / 20 * x ( 2 ) & + 1.d0 / 60 * x ( 3 ) & ) / delta end function subroutine print_matrix ( label , A , prec ) character ( len =* ), intent ( in ) :: label real ( dp ), intent ( in ) :: A (:, :) integer , optional , intent ( in ) :: prec integer :: m , n , i , j , prec_ character ( len = 10 ) :: fm if ( present ( prec )) then prec_ = prec else prec_ = 3 end if m = size ( A , 1 ) n = size ( A , 2 ) write ( fm , '(\"(g\",i2,\".\",i1,\")\")' ) prec_ + 8 , prec_ write ( 6 , '(A,\":\")' ) label do i = 1 , m do j = 1 , n write ( 6 , fm , advance = \"no\" ) A ( i , j ) end do write ( 6 , * ) end do end subroutine pure function lower ( str ) character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lower integer :: i do i = 1 , len ( str ) select case ( str ( i : i )) case ( 'A' : 'Z' ) lower ( i : i ) = achar ( iachar ( str ( i : i )) + 32 ) case default lower ( i : i ) = str ( i : i ) end select end do end function integer pure function findval_int ( array , val ) result ( idx ) integer , intent ( in ) :: array (:), val integer :: i idx = 0 do i = 1 , size ( array ) if ( val == array ( i )) then idx = i return end if end do end function subroutine shift_idx ( idx , start , finish ) integer , intent ( inout ) :: idx (:) integer , intent ( in ) :: start (:), finish (:) integer :: i_dim , i do i_dim = size ( idx ), 1 , - 1 i = idx ( i_dim ) + 1 if ( i <= finish ( i_dim )) then idx ( i_dim ) = i return else idx ( i_dim ) = start ( i_dim ) end if end do end subroutine subroutine clock_init ( this , n ) class ( clock_t ), intent ( inout ) :: this integer , intent ( in ) :: n allocate ( this % timestamps ( n ), this % counts ( n )) end subroutine subroutine clock_clock ( this , id ) class ( clock_t ), intent ( inout ) :: this integer , intent ( in ) :: id integer :: absid , cnt , rate , cnt_max if (. not . this % active ) return call system_clock ( cnt , rate , cnt_max ) if ( id > 0 ) then this % timestamps ( id ) = this % timestamps ( id ) - cnt else absid = abs ( id ) this % timestamps ( absid ) = this % timestamps ( absid ) + cnt this % counts ( absid ) = this % counts ( absid ) + 1 end if end subroutine logical function is_true ( val ) result ( res ) logical , intent ( in ), optional :: val res = . false . if ( present ( val )) res = val end function end module","tags":"","loc":"sourcefile/mbd_utils.f90.html"},{"title":"mbd_damping.F90 – Libmbd","text":"Contents Modules mbd_damping Source Code mbd_damping.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #include \"defaults.h\" module mbd_damping !! Damping functions. use mbd_constants use mbd_gradients , only : grad_scalar_t , grad_request_t use mbd_utils , only : lower , exception_t implicit none private public :: damping_fermi , damping_sqrtfermi , op1minus_grad type , public :: damping_t !! Represents a damping function. character ( len = 20 ) :: version real ( dp ) :: beta = 0 d0 real ( dp ) :: a = MBD_DAMPING_A real ( dp ) :: ts_d = TS_DAMPING_D real ( dp ) :: ts_sr = 0 d0 real ( dp ) :: mayer_scaling = 1 d0 real ( dp ), allocatable :: r_vdw (:) real ( dp ), allocatable :: sigma (:) real ( dp ), allocatable :: damping_custom (:, :) real ( dp ), allocatable :: potential_custom (:, :, :, :) contains procedure :: set_params_from_xc => damping_set_params_from_xc end type contains real ( dp ) function damping_fermi ( r , s_vdw , d , df , grad ) result ( f ) !!  !! \\begin{gathered} !! f_{(ij)}=\\frac1{1+\\exp\\big({-}a(\\eta-1)\\big)},\\qquad !! \\eta=\\frac{R_{(ij)}}{S_{\\text{vdW}(ij)}}\\equiv !! \\frac{R_{(ij)}}{\\beta R_{\\text{vdW}(ij)}} !! \\\\ \\frac{\\mathrm df}{\\mathrm dR_c}= !! \\frac a{2+2\\cosh\\big(a(\\eta-1)\\big)}\\frac{\\mathrm d\\eta}{\\mathrm dR_c},\\qquad !! \\frac{\\mathrm d\\eta}{\\mathrm dR_c}= !! \\frac{R_c}{RS_\\text{vdW}}- !! \\frac{R}{S_\\text{vdW}&#94;2}\\frac{\\mathrm dS_\\text{vdW}}{\\mathrm dR_c} !! \\end{gathered} !!  real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: s_vdw real ( dp ), intent ( in ) :: d type ( grad_scalar_t ), intent ( out ), optional :: df type ( grad_request_t ), intent ( in ), optional :: grad real ( dp ) :: pre , eta , r_1 r_1 = sqrt ( sum ( r ** 2 )) eta = r_1 / s_vdw f = 1 d0 / ( 1 + exp ( - d * ( eta - 1 ))) if (. not . present ( grad )) return pre = d / ( 2 + 2 * cosh ( d - d * eta )) if ( grad % dcoords ) df % dr = pre * r / ( r_1 * s_vdw ) if ( grad % dr_vdw ) df % dvdw = - pre * r_1 / s_vdw ** 2 end function real ( dp ) function damping_sqrtfermi ( r , s_vdw , d ) result ( f ) real ( dp ), intent ( in ) :: r ( 3 ) real ( dp ), intent ( in ) :: s_vdw real ( dp ), intent ( in ) :: d f = sqrt ( damping_fermi ( r , s_vdw , d )) end function subroutine op1minus_grad ( f , df ) real ( dp ), intent ( inout ) :: f type ( grad_scalar_t ), intent ( inout ) :: df f = 1 - f if ( allocated ( df % dr )) df % dr = - df % dr if ( allocated ( df % dvdw )) df % dvdw = - df % dvdw end subroutine type ( exception_t ) function damping_set_params_from_xc ( this , xc , variant ) result ( exc ) class ( damping_t ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: xc character ( len =* ), intent ( in ) :: variant select case ( lower ( variant )) case ( 'ts' ) select case ( lower ( xc )) case ( 'pbe' ) this % ts_sr = 0.94d0 case ( 'pbe0' ) this % ts_sr = 0.96d0 case ( 'hse' ) this % ts_sr = 0.96d0 case ( 'blyp' ) this % ts_sr = 0.62d0 case ( 'b3lyp' ) this % ts_sr = 0.84d0 case ( 'revpbe' ) this % ts_sr = 0.60d0 case ( 'am05' ) this % ts_sr = 0.84d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter S_r of method TS unknown for ' // trim ( xc ) end select case ( 'mbd-rsscs' ) select case ( lower ( xc )) case ( 'pbe' ) this % beta = 0.83d0 case ( 'pbe0' ) this % beta = 0.85d0 case ( 'hse' ) this % beta = 0.85d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter beta of method MBD@rsSCS unknown for ' // trim ( xc ) end select case ( 'mbd-ts' ) select case ( lower ( xc )) case ( 'pbe' ) this % beta = 0.81d0 case ( 'pbe0' ) this % beta = 0.83d0 case ( 'hse' ) this % beta = 0.83d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter beta of method MBD@TS unknown for ' // trim ( xc ) end select case ( 'mbd-scs' ) this % beta = 1 d0 select case ( lower ( xc )) case ( 'pbe' ) this % a = 2.56d0 case ( 'pbe0' ) this % a = 2.53d0 case ( 'hse' ) this % a = 2.53d0 case default exc % code = MBD_EXC_DAMPING exc % msg = 'Damping parameter a of method MBD@SCS unknown for ' // trim ( xc ) end select case default exc % code = MBD_EXC_DAMPING exc % msg = 'Method is unkonwn: ' // trim ( variant ) end select end function end module","tags":"","loc":"sourcefile/mbd_damping.f90.html"},{"title":"mbd_scs.f90 – Libmbd","text":"Contents Modules mbd_scs Source Code mbd_scs.f90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. module mbd_scs !! Performing self-consistent screening. use mbd_constants use mbd_damping , only : damping_t use mbd_dipole , only : dipole_matrix use mbd_formulas , only : sigma_selfint use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_matrix_re_t , grad_request_t use mbd_matrix , only : matrix_re_t , contract_cross_33 use mbd_utils , only : findval implicit none private public :: run_scs contains function run_scs ( geom , alpha , damp , dalpha_scs , grad ) result ( alpha_scs ) !!  !! \\begin{gathered} !! \\bar\\alpha_i=\\tfrac13\\operatorname{Tr} !! \\big(\\textstyle\\sum_j\\boldsymbol{\\bar\\alpha}_{ij}\\big),\\qquad !! \\boldsymbol{\\bar\\alpha}=(\\boldsymbol\\alpha&#94;{-1}+\\mathbf T_\\text{GG})&#94;{-1} !! \\\\ \\partial\\boldsymbol{\\bar\\alpha}= !! -\\boldsymbol{\\bar\\alpha}( !! \\partial\\boldsymbol\\alpha&#94;{-1}+\\partial\\mathbf T_\\text{GG} !! )\\boldsymbol{\\bar\\alpha},\\qquad !! \\frac{\\partial\\bar\\alpha_i}{\\partial X_j}= !! -\\frac13\\sum_{\\zeta\\eta}\\big( !! B_{i\\zeta,j\\eta}\\bar\\alpha'_{\\zeta,j\\eta}+ !! B'_{j\\eta,\\zeta}\\bar\\alpha_{j\\eta,i\\zeta} !! \\big) !! \\\\ \\mathbf B=\\boldsymbol{\\bar\\alpha}\\mathbf A, !! \\quad A_{i\\zeta,j\\eta}= !! \\frac{\\partial(\\alpha_i&#94;{-1})}{\\partial X_i} !! \\delta_{ij}\\delta_{\\zeta\\eta}+ !! \\frac{\\partial T&#94;\\text{GG}_{i\\zeta,j\\eta}}{\\partial X_i},\\quad !! \\bar\\alpha'_{\\zeta,p}=\\sum_i\\bar\\alpha_{i\\zeta,p},\\quad !! B'_{p,\\zeta}=\\sum_iB_{p,i\\zeta} !! \\end{gathered} !!  type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha (:) type ( damping_t ), intent ( in ) :: damp type ( grad_t ), intent ( out ) :: dalpha_scs (:) type ( grad_request_t ), intent ( in ) :: grad real ( dp ) :: alpha_scs ( size ( alpha )) type ( matrix_re_t ) :: alpha_full , dQ , T integer :: n_atoms , i_xyz , i_atom , my_i_atom , i_latt type ( damping_t ) :: damp_local real ( dp ), allocatable :: dsij_dsi (:), dsigma_dalpha (:), & alpha_prime (:, :), B_prime (:, :), grads_i (:), dalphadA (:) type ( grad_matrix_re_t ) :: dT type ( grad_request_t ) :: grad_req n_atoms = geom % siz () damp_local = damp damp_local % sigma = sigma_selfint ( alpha , dsigma_dalpha , grad % dalpha ) grad_req = grad_request_t ( & dcoords = grad % dcoords , & dlattice = grad % dlattice , & dsigma = grad % dalpha , & dr_vdw = grad % dr_vdw & ) T = dipole_matrix ( geom , damp_local , dT , grad_req ) if ( geom % has_exc ()) return if ( grad % any ()) then call alpha_full % copy_from ( T ) else call alpha_full % move_from ( T ) end if call alpha_full % add_diag ( 1 d0 / alpha ) call geom % clock ( 32 ) call alpha_full % invh ( geom % exc ) if ( geom % has_exc ()) return call geom % clock ( - 32 ) alpha_scs = alpha_full % contract_n33diag_cols () if ( any ( alpha_scs < 0 )) then geom % exc % code = MBD_EXC_NEG_POL geom % exc % msg = 'Screening leads to negative polarizability' return end if if (. not . grad % any ()) return allocate ( alpha_prime ( 3 , 3 * n_atoms ), source = 0 d0 ) allocate ( B_prime ( 3 * n_atoms , 3 ), source = 0 d0 ) allocate ( grads_i ( n_atoms )) call alpha_full % contract_n_transp ( 'R' , alpha_prime ) call dQ % init_from ( T ) if ( grad % dcoords ) then do my_i_atom = 1 , size ( geom % idx % i_atom ) allocate ( dalpha_scs ( my_i_atom )% dcoords ( size ( geom % idx % j_atom ), 3 )) end do do i_xyz = 1 , 3 dQ % val = - dT % dr (:, :, i_xyz ) dQ = alpha_full % mmul ( dQ ) call dQ % contract_n_transp ( 'C' , B_prime ) do i_atom = 1 , n_atoms grads_i = contract_cross_33 ( & i_atom , dQ , alpha_prime , alpha_full , B_prime & ) my_i_atom = findval ( geom % idx % i_atom , i_atom ) if ( my_i_atom > 0 ) then dalpha_scs ( my_i_atom )% dcoords (:, i_xyz ) = & grads_i ( geom % idx % j_atom ) end if end do end do end if if ( grad % dlattice ) then do my_i_atom = 1 , size ( geom % idx % i_atom ) allocate ( dalpha_scs ( my_i_atom )% dlattice ( 3 , 3 )) end do do i_latt = 1 , 3 do i_xyz = 1 , 3 dQ % val = - dT % dlattice (:, :, i_latt , i_xyz ) dQ = alpha_full % mmul ( dQ ) dQ = dQ % mmul ( alpha_full ) dalphadA = dQ % contract_n33diag_cols () forall ( my_i_atom = 1 : size ( geom % idx % i_atom )) dalpha_scs ( my_i_atom )% dlattice ( i_latt , i_xyz ) & = dalphadA ( geom % idx % i_atom ( my_i_atom )) end forall end do end do end if if ( grad % dalpha ) then dQ % val = dT % dsigma do i_atom = 1 , n_atoms dsij_dsi = damp_local % sigma ( i_atom ) * dsigma_dalpha ( i_atom ) / & sqrt ( damp_local % sigma ( i_atom ) ** 2 + damp_local % sigma ** 2 ) call dQ % mult_col ( i_atom , dsij_dsi ) end do call dQ % add_diag ( - 0.5d0 / alpha ** 2 ) dQ = alpha_full % mmul ( dQ ) call dQ % contract_n_transp ( 'C' , B_prime ) do i_atom = 1 , n_atoms grads_i = contract_cross_33 ( & i_atom , dQ , alpha_prime , alpha_full , B_prime & ) my_i_atom = findval ( geom % idx % i_atom , i_atom ) if ( my_i_atom > 0 ) then dalpha_scs ( my_i_atom )% dalpha = grads_i ( geom % idx % j_atom ) end if end do end if if ( grad % dr_vdw ) then dQ % val = dT % dvdw dQ = alpha_full % mmul ( dQ ) call dQ % contract_n_transp ( 'C' , B_prime ) do i_atom = 1 , n_atoms grads_i = contract_cross_33 ( & i_atom , dQ , alpha_prime , alpha_full , B_prime & ) my_i_atom = findval ( geom % idx % i_atom , i_atom ) if ( my_i_atom > 0 ) then dalpha_scs ( my_i_atom )% dr_vdw = grads_i ( geom % idx % j_atom ) end if end do end if end function end module","tags":"","loc":"sourcefile/mbd_scs.f90.html"},{"title":"mbd_geom.F90 – Libmbd","text":"Contents Modules mbd_geom Source Code mbd_geom.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef LEGENDRE_PREC #define LEGENDRE_PREC 8 #endif #include \"defaults.h\" module mbd_geom !! Representing a molecule or a crystal unit cell. use mbd_constants use mbd_lapack , only : eigvals , inverse use mbd_utils , only : shift_idx , atom_index_t , quad_pt_t , exception_t , tostr , clock_t #ifdef WITH_SCALAPACK use mbd_blacs , only : blacs_desc_t , blacs_grid_t #endif #ifdef WITH_MPI use mbd_mpi #endif implicit none private public :: supercell_circum , get_freq_grid type , public :: param_t !! Calculation-wide paramters. real ( dp ) :: ts_energy_accuracy = TS_ENERGY_ACCURACY real ( dp ) :: ts_cutoff_radius = 50 d0 * ang real ( dp ) :: dipole_cutoff = 400 d0 * ang ! used only when Ewald is off real ( dp ) :: ewald_real_cutoff_scaling = 1 d0 real ( dp ) :: ewald_rec_cutoff_scaling = 1 d0 real ( dp ) :: k_grid_shift = K_GRID_SHIFT logical :: ewald_on = . true . logical :: zero_negative_eigvals = . false . integer :: rpa_order_max = 10 integer :: n_freq = N_FREQUENCY_GRID end type type , public :: geom_t !! Represents a molecule or a crystal unit cell. !! !! The documented variables should be set before calling the initializer. real ( dp ), allocatable :: coords (:, :) !! (3\\times N, a.u.) Atomic coordinates. real ( dp ), allocatable :: lattice (:, :) !! (3\\times 3, a.u.) Lattice vectors in columns, unallocated if not !! periodic. integer , allocatable :: k_grid (:) !! Number of k-points along reciprocal axes. character ( len = 10 ) :: parallel_mode = 'auto' !! Type of parallelization: !! !! - `atoms`: distribute matrices over all MPI tasks using ScaLAPACK, !! solve eigenproblems sequentialy. !! - `k_points`: parallelize over k-points (each MPI task solves entire !! eigenproblems for its k-points) logical :: get_eigs = . false . !! Whether to keep MBD eigenvalues logical :: get_modes = . false . !! Whether to calculate MBD eigenvectors logical :: do_rpa = . false . !! Whether to calculate MBD energy by frequency integration logical :: get_rpa_orders = . false . !! Whether to calculate RPA orders ! The following components are set by the initializer and should be ! considered read-only type ( clock_t ) :: clock_ type ( exception_t ) :: exc logical :: muted = . false . type ( quad_pt_t ), allocatable :: freq (:) real ( dp ) :: gamm = 0 d0 real ( dp ) :: real_space_cutoff real ( dp ) :: rec_space_cutoff type ( param_t ) :: param type ( atom_index_t ) :: idx #ifdef WITH_SCALAPACK ! TODO makes these two private (see use in mbd_methods, mbd_dipole) type ( blacs_desc_t ) :: blacs type ( blacs_grid_t ) :: blacs_grid #endif #ifdef WITH_MPI integer :: comm = MPI_COMM_WORLD #endif contains procedure :: init => geom_init procedure :: destroy => geom_destroy procedure :: siz => geom_siz procedure :: has_exc => geom_has_exc procedure :: clock => geom_clock end type contains subroutine geom_init ( this ) class ( geom_t ), intent ( inout ) :: this integer :: i_atom real ( dp ) :: volume associate ( n => this % param % n_freq ) allocate ( this % freq ( 0 : n )) call get_freq_grid ( n , this % freq ( 1 : n )% val , this % freq ( 1 : n )% weight ) end associate this % freq ( 0 )% val = 0 d0 this % freq ( 0 )% weight = 0 d0 call this % clock_ % init ( 100 ) if ( allocated ( this % lattice )) then volume = abs ( dble ( product ( eigvals ( this % lattice )))) if ( this % param % ewald_on ) then this % gamm = 2.5d0 / volume ** ( 1 d0 / 3 ) this % real_space_cutoff = 6 d0 / this % gamm * this % param % ewald_real_cutoff_scaling this % rec_space_cutoff = 10 d0 * this % gamm * this % param % ewald_rec_cutoff_scaling else this % real_space_cutoff = this % param % dipole_cutoff end if end if if ( this % parallel_mode == 'auto' ) then this % parallel_mode = 'atoms' if ( allocated ( this % lattice ) . and . allocated ( this % k_grid )) then if ( this % siz () ** 2 < product ( this % k_grid )) then this % parallel_mode = 'atoms' end if end if end if #ifdef WITH_SCALAPACK this % idx % parallel = this % parallel_mode == 'atoms' . and . this % siz () > 1 if ( this % idx % parallel ) then #   ifdef WITH_MPI call this % blacs_grid % init ( this % comm ) #   else call this % blacs_grid % init () #   endif call this % blacs % init ( this % siz (), this % blacs_grid ) this % idx % i_atom = this % blacs % i_atom this % idx % j_atom = this % blacs % j_atom else this % idx % i_atom = [( i_atom , i_atom = 1 , this % siz ())] this % idx % j_atom = this % idx % i_atom end if #else this % idx % i_atom = [( i_atom , i_atom = 1 , this % siz ())] this % idx % j_atom = this % idx % i_atom #endif this % idx % n_atoms = this % siz () end subroutine subroutine geom_destroy ( this ) class ( geom_t ), intent ( inout ) :: this #ifdef WITH_SCALAPACK if ( this % idx % parallel ) call this % blacs_grid % destroy () #endif deallocate ( this % freq ) deallocate ( this % clock_ % timestamps ) deallocate ( this % clock_ % counts ) end subroutine integer function geom_siz ( this ) result ( siz ) class ( geom_t ), intent ( in ) :: this if ( allocated ( this % coords )) then siz = size ( this % coords , 2 ) else siz = 0 end if end function logical function geom_has_exc ( this ) result ( has_exc ) class ( geom_t ), intent ( in ) :: this has_exc = this % exc % code /= 0 end function function supercell_circum ( lattice , radius ) result ( sc ) real ( dp ), intent ( in ) :: lattice ( 3 , 3 ) real ( dp ), intent ( in ) :: radius integer :: sc ( 3 ) real ( dp ) :: ruc ( 3 , 3 ), layer_sep ( 3 ) integer :: i ruc = 2 * pi * inverse ( transpose ( lattice )) forall ( i = 1 : 3 ) & layer_sep ( i ) = sum ( lattice (:, i ) * ruc (:, i ) / sqrt ( sum ( ruc (:, i ) ** 2 ))) sc = ceiling ( radius / layer_sep + 0.5d0 ) end function subroutine geom_clock ( this , id ) class ( geom_t ), intent ( inout ) :: this integer , intent ( in ) :: id call this % clock_ % clock ( id ) end subroutine subroutine get_freq_grid ( n , x , w , L ) integer , intent ( in ) :: n real ( dp ), intent ( out ) :: x ( n ), w ( n ) real ( dp ), intent ( in ), optional :: L real ( dp ) :: L_ if ( present ( L )) then L_ = L else L_ = 0.6d0 end if call gauss_legendre ( n , x , w ) w = 2 * L_ / ( 1 - x ) ** 2 * w x = L_ * ( 1 + x ) / ( 1 - x ) w = w ( n : 1 : - 1 ) x = x ( n : 1 : - 1 ) end subroutine subroutine gauss_legendre ( n , r , w ) integer , intent ( in ) :: n real ( dp ), intent ( out ) :: r ( n ), w ( n ) integer , parameter :: q = LEGENDRE_PREC integer , parameter :: n_iter = 1000 real ( q ) :: x , f , df , dx integer :: k , iter , i real ( q ) :: Pk ( 0 : n ), Pk1 ( 0 : n - 1 ), Pk2 ( 0 : n - 2 ) if ( n == 1 ) then r ( 1 ) = 0 d0 w ( 1 ) = 2 d0 return end if Pk2 ( 0 ) = 1. _ q ! k = 0 Pk1 ( 0 : 1 ) = [ 0. _ q , 1. _ q ] ! k = 1 do k = 2 , n Pk ( 0 : k ) = (( 2 * k - 1 ) * & [ 0. _ q , Pk1 ( 0 : k - 1 )] - ( k - 1 ) * [ Pk2 ( 0 : k - 2 ), 0. _ q , 0. _ q ]) / k if ( k < n ) then Pk2 ( 0 : k - 1 ) = Pk1 ( 0 : k - 1 ) Pk1 ( 0 : k ) = Pk ( 0 : k ) end if end do ! now Pk contains k-th Legendre polynomial do i = 1 , n x = cos ( pi * ( i - 0.25 _ q ) / ( n + 0.5 _ q )) do iter = 1 , n_iter df = 0. _ q f = Pk ( n ) do k = n - 1 , 0 , - 1 df = f + x * df f = Pk ( k ) + x * f end do dx = f / df x = x - dx if ( abs ( dx ) < 10 * epsilon ( dx )) exit end do r ( i ) = dble ( x ) w ( i ) = dble ( 2 / (( 1 - x ** 2 ) * df ** 2 )) end do end subroutine end module","tags":"","loc":"sourcefile/mbd_geom.f90.html"},{"title":"mbd_hamiltonian.F90 – Libmbd","text":"Contents Modules mbd_hamiltonian Source Code mbd_hamiltonian.F90 Source Code ! This Source Code Form is subject to the terms of the Mozilla Public ! License, v. 2.0. If a copy of the MPL was not distributed with this ! file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef MBD_TYPE module mbd_hamiltonian !! Forming and solving MBD Hamiltonian. use mbd_constants use mbd_damping , only : damping_t use mbd_dipole , only : dipole_matrix use mbd_geom , only : geom_t use mbd_gradients , only : grad_t , grad_matrix_re_t , grad_matrix_cplx_t , grad_request_t use mbd_matrix , only : matrix_re_t , matrix_cplx_t use mbd_utils , only : result_t , tostr implicit none private public :: get_mbd_hamiltonian_energy interface get_mbd_hamiltonian_energy !! Form and solve either a real or a complex MBD Hamiltonian. !! !! The real-typed version is equivalent to \\mathbf q=0. !! !!  !! \\begin{gathered} !! E_\\text{MBD}(\\mathbf q)=\\frac12\\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf !! q)}\\big)- 3\\sum_i\\frac{\\omega_i}2,\\qquad !! \\mathbf Q_{ij}(\\mathbf q)=\\omega_i&#94;2\\delta_{ij}\\mathbf I+ !! \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}(\\mathbf q) !! \\\\ \\mathbf Q(\\mathbf q)\\equiv !! \\mathbf C(\\mathbf q)\\boldsymbol\\Lambda(\\mathbf q)\\mathbf C(\\mathbf !! q)&#94;\\dagger,\\qquad !! \\boldsymbol\\Lambda(\\mathbf q) !! \\equiv\\operatorname{diag}(\\{\\tilde\\omega_i(\\mathbf q)&#94;2\\}),\\qquad !! \\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf q)}\\big) !! =\\sum_i\\tilde\\omega_i(\\mathbf q) !! \\end{gathered} !!  !! !!  !! \\begin{aligned} !! \\partial E_\\text{MBD}&=\\frac14\\operatorname{Tr}\\big( !! \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger !! \\partial\\mathbf Q !! \\big)- !! 3\\sum_i\\frac{\\partial\\omega_i}2 !! \\\\ \\frac{\\partial E_\\text{MBD}}{\\partial X_i}&= !! \\operatorname{Re}\\frac12\\sum_{p\\zeta}( !! \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger !! )_{i\\zeta,p} !! \\frac{\\partial Q_{p,i\\zeta}}{\\partial X_i}- !! \\frac32\\frac{\\partial\\omega_i}{\\partial X_i} !! \\end{aligned} !!  !! !!  !! \\begin{aligned} !! \\partial\\mathbf Q_{ij}=& !! 2\\delta_{ij}\\omega_i\\partial\\omega_i\\mathbf I+ !! \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}\\left( !! \\frac{\\partial\\omega_i}{\\omega_i}+ !! \\frac{\\partial\\omega_j}{\\omega_j}+ !! \\frac12\\frac{\\partial\\alpha_{0,i}}{\\alpha_{0,i}}+ !! \\frac12\\frac{\\partial\\alpha_{0,j}}{\\alpha_{0,j}} !! \\right) !! \\\\ &+\\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}} !! \\partial\\mathbf T_{ij} !! \\end{aligned} !!  module procedure get_mbd_hamiltonian_energy_real module procedure get_mbd_hamiltonian_energy_complex end interface contains #   define MBD_TYPE 0 #endif #if MBD_TYPE == 0 type ( result_t ) function get_mbd_hamiltonian_energy_real ( & geom , alpha_0 , omega , damp , dene , grad ) result ( res ) #elif MBD_TYPE == 1 type ( result_t ) function get_mbd_hamiltonian_energy_complex ( & geom , alpha_0 , omega , damp , dene , grad , q ) result ( res ) #endif type ( geom_t ), intent ( inout ) :: geom real ( dp ), intent ( in ) :: alpha_0 (:) real ( dp ), intent ( in ) :: omega (:) type ( damping_t ), intent ( in ) :: damp type ( grad_t ), intent ( out ) :: dene type ( grad_request_t ), intent ( in ) :: grad #if MBD_TYPE == 1 real ( dp ), intent ( in ) :: q ( 3 ) #endif #if MBD_TYPE == 0 type ( matrix_re_t ) :: relay , dQ , T , modes , c_lambda12i_c type ( grad_matrix_re_t ) :: dT #elif MBD_TYPE == 1 type ( matrix_cplx_t ) :: relay , dQ , T , modes , c_lambda12i_c type ( grad_matrix_cplx_t ) :: dT #endif real ( dp ), allocatable :: eigs (:) integer :: n_negative_eigs , n_atoms , i_xyz , i_latt character ( 120 ) :: msg n_atoms = geom % siz () #if MBD_TYPE == 0 T = dipole_matrix ( geom , damp , dT , grad ) #elif MBD_TYPE == 1 T = dipole_matrix ( geom , damp , dT , grad , q ) #endif if ( geom % has_exc ()) return if ( grad % any ()) then call relay % copy_from ( T ) else call relay % move_from ( T ) end if call relay % mult_cross ( omega * sqrt ( alpha_0 )) call relay % add_diag ( omega ** 2 ) call geom % clock ( 21 ) if ( geom % get_modes . or . grad % any ()) then call modes % alloc_from ( relay ) allocate ( eigs ( 3 * n_atoms )) call modes % eigh ( eigs , geom % exc , src = relay ) if ( geom % get_modes ) then #if MBD_TYPE == 0 call move_alloc ( modes % val , res % modes ) #elif MBD_TYPE == 1 call move_alloc ( modes % val , res % modes_k_single ) #endif end if else eigs = relay % eigvalsh ( geom % exc , destroy = . true .) end if if ( geom % has_exc ()) return call geom % clock ( - 21 ) if ( geom % get_eigs ) res % mode_eigs = eigs n_negative_eigs = count ( eigs (:) < 0 ) if ( n_negative_eigs > 0 ) then msg = \"CDM Hamiltonian has \" // trim ( tostr ( n_negative_eigs )) // & \" negative eigenvalues\" if ( geom % param % zero_negative_eigvals ) then where ( eigs < 0 ) eigs = 0 d0 ! call geom%calc%print(msg) ! TODO add warning mechanism else geom % exc % code = MBD_EXC_NEG_EIGVALS geom % exc % msg = msg return end if end if res % energy = 1 d0 / 2 * sum ( sqrt ( eigs )) - 3 d0 / 2 * sum ( omega ) if (. not . grad % any ()) return call c_lambda12i_c % copy_from ( modes ) call c_lambda12i_c % mult_cols_3n ( eigs ** ( - 1 d0 / 4 )) c_lambda12i_c = c_lambda12i_c % mmul ( c_lambda12i_c , transB = 'C' ) #if MBD_TYPE == 1 c_lambda12i_c % val = conjg ( c_lambda12i_c % val ) #endif call dQ % init_from ( T ) if ( grad % dcoords ) then allocate ( dene % dcoords ( n_atoms , 3 )) do i_xyz = 1 , 3 dQ % val = dT % dr (:, :, i_xyz ) call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val dene % dcoords (:, i_xyz ) = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) end do end if if ( grad % dlattice ) then allocate ( dene % dlattice ( 3 , 3 )) do i_latt = 1 , 3 do i_xyz = 1 , 3 dQ % val = dT % dlattice (:, :, i_latt , i_xyz ) call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val dene % dlattice ( i_latt , i_xyz ) = 1 d0 / 4 * dble ( dQ % sum_all ()) end do end do end if if ( grad % dalpha ) then dQ % val = T % val call dQ % mult_cross ( omega * sqrt ( alpha_0 )) call dQ % mult_rows ( 1 d0 / ( 2 * alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val dene % dalpha = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) end if if ( grad % domega ) then dQ % val = T % val call dQ % mult_cross ( omega * sqrt ( alpha_0 )) call dQ % mult_rows ( 1 d0 / omega ) call dQ % add_diag ( omega ) dQ % val = c_lambda12i_c % val * dQ % val dene % domega = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) - 3 d0 / 2 end if if ( grad % dr_vdw ) then dQ % val = dT % dvdw call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val dene % dr_vdw = 1 d0 / 2 * dble ( dQ % contract_n33_rows ()) end if #if MBD_TYPE == 1 if ( grad % dq ) then allocate ( dene % dq ( 3 )) do i_latt = 1 , 3 dQ % val = dT % dq (:, :, i_latt ) call dQ % mult_cross ( omega * sqrt ( alpha_0 )) dQ % val = c_lambda12i_c % val * dQ % val dene % dq ( i_latt ) = 1 d0 / 4 * dble ( dQ % sum_all ()) end do end if #endif end function #if MBD_TYPE == 0 #   undef MBD_TYPE #   define MBD_TYPE 1 #   include \"mbd_hamiltonian.F90\" end module #endif","tags":"","loc":"sourcefile/mbd_hamiltonian.f90.html"},{"title":"mbd_input_t – Libmbd ","text":"type, public :: mbd_input_t Contains user input to an MBD calculation. Contents Variables method comm calculate_forces calculate_spectrum ts_ene_acc ts_f_acc n_omega_grid k_grid_shift zero_negative_eigvals xc ts_d ts_sr mbd_a mbd_beta vdw_params_kind atom_types free_values coords lattice_vectors k_grid parallel_mode Components Type Visibility Attributes Name Initial character(len=30), public :: method = 'mbd-rsscs' VdW method to use to calculate energy and gradients. mbd-rsscs : The MBD@rsSCS method. mbd-nl : The MBD-NL method. ts : The TS method. mbd : Generic MBD method (without any screening). integer, public :: comm = -1 MPI communicator. Only used when compiled with MPI. Leave as is to use the\n MPI_COMM_WORLD communicator. logical, public :: calculate_forces = .true. Whether to calculate forces. logical, public :: calculate_spectrum = .false. Whether to keep MBD eigenvalues. real(kind=dp), public :: ts_ene_acc = 1d-6 Required accuracy of the TS energy. real(kind=dp), public :: ts_f_acc = 1d-7 Required accuracy of the TS gradients. integer, public :: n_omega_grid = 15 Number of imaginary frequency grid points. real(kind=dp), public :: k_grid_shift = 0.5d0 Off- \\Gamma shift of the k -point grid in units of\n inter- k -point distance. logical, public :: zero_negative_eigvals = .false. Whether to zero out negative eigenvalues. character(len=20), public :: xc = '' XC functional for automatic setting of damping parameters. real(kind=dp), public :: ts_d = 20d0 TS damping parameter d . real(kind=dp), public :: ts_sr = -1 Custom TS damping parameter s_R . Leave as is to use a value based on the XC functional. real(kind=dp), public :: mbd_a = 6d0 MBD damping parameter a . real(kind=dp), public :: mbd_beta = -1 Custom MBD damping parameter \\beta . Leave as is to use a value based on the XC functional. character(len=10), public :: vdw_params_kind = 'ts' Which free-atom reference vdW parameters to use for scaling. ts : Values from original TS method. tssurf : Values from the TS &#94;\\text{surf} approach. character(len=3), public, allocatable :: atom_types (:) ( N ) Atom types used for picking free-atom reference values. real(kind=dp), public, allocatable :: free_values (:,:) ( N\\times3 , a.u.) Custom free-atom vdW paramters to use for\n scaling. Columns contain static polarizabilities, C6 coefficients, and vdW\n radii. real(kind=dp), public, allocatable :: coords (:,:) ( 3\\times N , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice_vectors (:,:) ( 3\\times 3 , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public :: k_grid (3) = [-1, -1, -1] Number of k -points along reciprocal axes. character(len=10), public :: parallel_mode = 'auto' Parallelization scheme. auto : Pick based on system system size and number of k -points. kpoints : Parallelize over k -points. atoms : Parallelize over atom pairs.","tags":"","loc":"type/mbd_input_t.html"},{"title":"mbd_calc_t – Libmbd ","text":"type, public :: mbd_calc_t Represents an MBD calculation. Contents Type-Bound Procedures init destroy update_coords update_lattice_vectors update_vdw_params_custom update_vdw_params_from_ratios update_vdw_params_nl evaluate_vdw_method get_gradients get_lattice_derivs get_spectrum_modes get_exception Type-Bound Procedures procedure, public :: init => mbd_calc_init private subroutine mbd_calc_init(this, input) Initialize an MBD calculation from an MBD input. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout), target :: this type( mbd_input_t ), intent(in) :: input MBD input. procedure, public :: destroy => mbd_calc_destroy private subroutine mbd_calc_destroy(this) Finalize an MBD calculation. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout), target :: this procedure, public :: update_coords => mbd_calc_update_coords private subroutine mbd_calc_update_coords(this, coords) Update atomic coordinates. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: coords (:,:) ( 3\\times N , a.u.) New atomic coordinates. procedure, public :: update_lattice_vectors => mbd_calc_update_lattice_vectors private subroutine mbd_calc_update_lattice_vectors(this, latt_vecs) Update unit-cell lattice vectors. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: latt_vecs (:,:) ( 3\\times 3 , a.u.) New lattice vectors in columns. procedure, public :: update_vdw_params_custom => mbd_calc_update_vdw_params_custom private subroutine mbd_calc_update_vdw_params_custom(this, alpha_0, C6, r_vdw) Update vdW parameters in a custom way. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: alpha_0 (:) (a.u.) New atomic static polarizabilities. real(kind=dp), intent(in) :: C6 (:) (a.u.) New atomic C_6 coefficients. real(kind=dp), intent(in) :: r_vdw (:) (a.u.) New atomic vdW radii. procedure, public :: update_vdw_params_from_ratios => mbd_calc_update_vdw_params_from_ratios private subroutine mbd_calc_update_vdw_params_from_ratios(this, ratios) Update vdW parameters based on scaling of free-atom values. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: ratios (:) Ratios of atomic volumes in the system and in vacuum. procedure, public :: update_vdw_params_nl => mbd_calc_update_vdw_params_nl private subroutine mbd_calc_update_vdw_params_nl(this, alpha_0_ratios, C6_ratios) Update vdW parameters for the MBD-NL method. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(in) :: alpha_0_ratios (:) Ratios of free-atom exact static polarizabilities and those from the\n VV functional. real(kind=dp), intent(in) :: C6_ratios (:) Ratios of free-atom exact C_6 coefficients and those from the VV\n functional. procedure, public :: evaluate_vdw_method => mbd_calc_evaluate_vdw_method private subroutine mbd_calc_evaluate_vdw_method(this, energy) Evaluate a given vdW method for a given system and vdW parameters,\n retrieve energy. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(out) :: energy (a.u.) VdW energy. procedure, public :: get_gradients => mbd_calc_get_gradients private subroutine mbd_calc_get_gradients(this, gradients) Retrieve nuclear energy gradients if they were requested in the MBD\n input. The gradients are calculated together with the energy, so a call to this\n method must be preceeded by a call to evaluate_vdw_method .  For the same reason, the\n gradients must be requested prior to this called via calculate_forces . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(in) :: this real(kind=dp), intent(out) :: gradients (:,:) ( 3\\times N , a.u.) Energy gradients, \\mathrm dE/\\mathrm d\\mathbf\n R_i , index i runs over columns. procedure, public :: get_lattice_derivs => mbd_calc_get_lattice_derivs private subroutine mbd_calc_get_lattice_derivs(this, latt_derivs) Provide lattice-vector energy gradients if they were requested in the MBD\n input. The gradients are actually calculated together with the energy, so a call\n to this method must be preceeded by a call to evaluate_vdw_method .  For the same reason, the\n gradients must be requested prior to this called via calculate_forces . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(in) :: this real(kind=dp), intent(out) :: latt_derivs (:,:) ( 3\\times 3 , a.u.) Energy gradients, \\mathrm dE/\\mathrm d\\mathbf\n a_i , index i runs over columns. procedure, public :: get_spectrum_modes => mbd_calc_get_spectrum_modes private subroutine mbd_calc_get_spectrum_modes(this, spectrum, modes) Provide MBD spectrum if it was requested in the MBD input. The spectrum is actually calculated together with the energy, so a call\n to this method must be preceeded by a call to evaluate_vdw_method .  For the same reason, the\n spectrum must be requested prior to this called via calculate_spectrum . Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this real(kind=dp), intent(out) :: spectrum (:) ( 3N , a.u.) Energies (frequencies) of coupled MBD modues, \\omega_i . real(kind=dp), intent(out), optional allocatable :: modes (:,:) ( 3N\\times 3N ) Coupled-mode wave functions (MBD eigenstates), \\psi_j , in the basis of uncoupled states, C_{ij}=\\langle\\phi_i|\\psi_j\\rangle , index j runs over\n columns. To save memory, the argument must be allocatable, and the method\n transfers allocation from the internal state to the argument. For\n this reason, the method can be called only once wih this optional\n argument per calculation. procedure, public :: get_exception => mbd_calc_get_exception private subroutine mbd_calc_get_exception(this, code, origin, msg) Retrieve an exception in the MBD calculation if it occured. Arguments Type Intent Optional Attributes Name class( mbd_calc_t ), intent(inout) :: this integer, intent(out) :: code Exception code, values defined in mbd_constants . character(len=*), intent(out) :: origin Exception origin. character(len=*), intent(out) :: msg Exception message.","tags":"","loc":"type/mbd_calc_t.html"},{"title":"grad_t – Libmbd ","text":"type, public :: grad_t Derivatives with respect to various quantities Contents Variables dcoords dlattice dalpha dalpha_dyn dC6 dq dr_vdw domega dV dV_free dX_free Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dcoords (:,:) real(kind=dp), public, allocatable :: dlattice (:,:) real(kind=dp), public, allocatable :: dalpha (:) real(kind=dp), public, allocatable :: dalpha_dyn (:,:) real(kind=dp), public, allocatable :: dC6 (:) real(kind=dp), public, allocatable :: dq (:) real(kind=dp), public, allocatable :: dr_vdw (:) real(kind=dp), public, allocatable :: domega (:) real(kind=dp), public, allocatable :: dV (:) real(kind=dp), public, allocatable :: dV_free (:) real(kind=dp), public, allocatable :: dX_free (:)","tags":"","loc":"type/grad_t.html"},{"title":"grad_matrix_re_t – Libmbd ","text":"type, public :: grad_matrix_re_t Derivatives of a real dipole matrix with respect to various quantities Contents Variables dr dlattice dvdw dsigma dgamma Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:,:,:) real(kind=dp), public, allocatable :: dlattice (:,:,:,:) real(kind=dp), public, allocatable :: dvdw (:,:) real(kind=dp), public, allocatable :: dsigma (:,:) real(kind=dp), public, allocatable :: dgamma (:,:)","tags":"","loc":"type/grad_matrix_re_t.html"},{"title":"grad_matrix_cplx_t – Libmbd ","text":"type, public :: grad_matrix_cplx_t Derivatives of a compelx dipole matrix with respect to various quantities Contents Variables dr dlattice dq dvdw dsigma dgamma Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: dr (:,:,:) complex(kind=dp), public, allocatable :: dlattice (:,:,:,:) complex(kind=dp), public, allocatable :: dq (:,:,:) complex(kind=dp), public, allocatable :: dvdw (:,:) complex(kind=dp), public, allocatable :: dsigma (:,:) complex(kind=dp), public, allocatable :: dgamma (:,:)","tags":"","loc":"type/grad_matrix_cplx_t.html"},{"title":"grad_scalar_t – Libmbd ","text":"type, public :: grad_scalar_t Derivatives of a scalar with respect to various quantities Contents Variables dr dr_1 dvdw dgamma Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:) real(kind=dp), public, allocatable :: dr_1 real(kind=dp), public, allocatable :: dvdw real(kind=dp), public, allocatable :: dgamma","tags":"","loc":"type/grad_scalar_t.html"},{"title":"grad_request_t – Libmbd ","text":"type, public :: grad_request_t Used to request derivatives with respect to function arguments Contents Variables dcoords dalpha dalpha_dyn dC6 dr_vdw domega dsigma dgamma dq dlattice dV dV_free dX_free Type-Bound Procedures any Components Type Visibility Attributes Name Initial logical, public :: dcoords = .false. logical, public :: dalpha = .false. logical, public :: dalpha_dyn = .false. logical, public :: dC6 = .false. logical, public :: dr_vdw = .false. logical, public :: domega = .false. logical, public :: dsigma = .false. logical, public :: dgamma = .false. logical, public :: dq = .false. logical, public :: dlattice = .false. logical, public :: dV = .false. logical, public :: dV_free = .false. logical, public :: dX_free = .false. Type-Bound Procedures procedure, public :: any => grad_request_any private function grad_request_any(this) result(any) Arguments Type Intent Optional Attributes Name class( grad_request_t ), intent(in) :: this Return Value logical","tags":"","loc":"type/grad_request_t.html"},{"title":"exception_t – Libmbd ","text":"type, public :: exception_t Represents an exception. Contents Variables code origin msg Components Type Visibility Attributes Name Initial integer, public :: code = 0 character(len=50), public :: origin = '(unknown)' character(len=150), public :: msg = ''","tags":"","loc":"type/exception_t.html"},{"title":"result_t – Libmbd ","text":"type, public :: result_t Stores results from an MBD calculation Contents Variables energy mode_eigs modes rpa_orders mode_eigs_k modes_k modes_k_single rpa_orders_k Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy real(kind=dp), public, allocatable :: mode_eigs (:) real(kind=dp), public, allocatable :: modes (:,:) real(kind=dp), public, allocatable :: rpa_orders (:) real(kind=dp), public, allocatable :: mode_eigs_k (:,:) complex(kind=dp), public, allocatable :: modes_k (:,:,:) complex(kind=dp), public, allocatable :: modes_k_single (:,:) real(kind=dp), public, allocatable :: rpa_orders_k (:,:)","tags":"","loc":"type/result_t.html"},{"title":"atom_index_t – Libmbd ","text":"type, public :: atom_index_t Maps from atom indexes to positions in matrices. Contents Variables i_atom j_atom n_atoms parallel Components Type Visibility Attributes Name Initial integer, public, allocatable :: i_atom (:) integer, public, allocatable :: j_atom (:) integer, public :: n_atoms logical, public :: parallel","tags":"","loc":"type/atom_index_t.html"},{"title":"clock_t – Libmbd ","text":"type, public :: clock_t Used for measuring performance. Contents Variables active timestamps counts Type-Bound Procedures init clock Components Type Visibility Attributes Name Initial logical, public :: active = .true. integer, public, allocatable :: timestamps (:) integer, public, allocatable :: counts (:) Type-Bound Procedures procedure, public :: init => clock_init private subroutine clock_init(this, n) Arguments Type Intent Optional Attributes Name class( clock_t ), intent(inout) :: this integer, intent(in) :: n procedure, public :: clock => clock_clock private subroutine clock_clock(this, id) Arguments Type Intent Optional Attributes Name class( clock_t ), intent(inout) :: this integer, intent(in) :: id","tags":"","loc":"type/clock_t.html"},{"title":"quad_pt_t – Libmbd ","text":"type, public :: quad_pt_t Represents a 1D quadrature point Contents Variables val weight Components Type Visibility Attributes Name Initial real(kind=dp), public :: val real(kind=dp), public :: weight","tags":"","loc":"type/quad_pt_t.html"},{"title":"damping_t – Libmbd ","text":"type, public :: damping_t Represents a damping function. Contents Variables version beta a ts_d ts_sr mayer_scaling r_vdw sigma damping_custom potential_custom Type-Bound Procedures set_params_from_xc Components Type Visibility Attributes Name Initial character(len=20), public :: version real(kind=dp), public :: beta = 0d0 real(kind=dp), public :: a = 6d0 real(kind=dp), public :: ts_d = 20d0 real(kind=dp), public :: ts_sr = 0d0 real(kind=dp), public :: mayer_scaling = 1d0 real(kind=dp), public, allocatable :: r_vdw (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: damping_custom (:,:) real(kind=dp), public, allocatable :: potential_custom (:,:,:,:) Type-Bound Procedures procedure, public :: set_params_from_xc => damping_set_params_from_xc private function damping_set_params_from_xc(this, xc, variant) result(exc) Arguments Type Intent Optional Attributes Name class( damping_t ), intent(inout) :: this character(len=*), intent(in) :: xc character(len=*), intent(in) :: variant Return Value type( exception_t )","tags":"","loc":"type/damping_t.html"},{"title":"param_t – Libmbd ","text":"type, public :: param_t Calculation-wide paramters. Contents Variables ts_energy_accuracy ts_cutoff_radius dipole_cutoff ewald_real_cutoff_scaling ewald_rec_cutoff_scaling k_grid_shift ewald_on zero_negative_eigvals rpa_order_max n_freq Components Type Visibility Attributes Name Initial real(kind=dp), public :: ts_energy_accuracy = 1d-6 real(kind=dp), public :: ts_cutoff_radius = 50d0*ang real(kind=dp), public :: dipole_cutoff = 400d0*ang real(kind=dp), public :: ewald_real_cutoff_scaling = 1d0 real(kind=dp), public :: ewald_rec_cutoff_scaling = 1d0 real(kind=dp), public :: k_grid_shift = 0.5d0 logical, public :: ewald_on = .true. logical, public :: zero_negative_eigvals = .false. integer, public :: rpa_order_max = 10 integer, public :: n_freq = 15","tags":"","loc":"type/param_t.html"},{"title":"geom_t – Libmbd ","text":"type, public :: geom_t Represents a molecule or a crystal unit cell. The documented variables should be set before calling the initializer. Contents Variables coords lattice k_grid parallel_mode get_eigs get_modes do_rpa get_rpa_orders clock_ exc muted freq gamm real_space_cutoff rec_space_cutoff param idx blacs blacs_grid comm Type-Bound Procedures init destroy siz has_exc clock Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: coords (:,:) ( 3\\times N , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice (:,:) ( 3\\times 3 , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public, allocatable :: k_grid (:) Number of k -points along reciprocal axes. character(len=10), public :: parallel_mode = 'auto' Type of parallelization: atoms : distribute matrices over all MPI tasks using ScaLAPACK,\n solve eigenproblems sequentialy. k_points : parallelize over k-points (each MPI task solves entire\n eigenproblems for its k-points) logical, public :: get_eigs = .false. Whether to keep MBD eigenvalues logical, public :: get_modes = .false. Whether to calculate MBD eigenvectors logical, public :: do_rpa = .false. Whether to calculate MBD energy by frequency integration logical, public :: get_rpa_orders = .false. Whether to calculate RPA orders type( clock_t ), public :: clock_ type( exception_t ), public :: exc logical, public :: muted = .false. type( quad_pt_t ), public, allocatable :: freq (:) real(kind=dp), public :: gamm = 0d0 real(kind=dp), public :: real_space_cutoff real(kind=dp), public :: rec_space_cutoff type( param_t ), public :: param type( atom_index_t ), public :: idx type(blacs_desc_t), public :: blacs type(blacs_grid_t), public :: blacs_grid integer, public :: comm = MPI_COMM_WORLD Type-Bound Procedures procedure, public :: init => geom_init private subroutine geom_init(this) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(inout) :: this procedure, public :: destroy => geom_destroy private subroutine geom_destroy(this) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(inout) :: this procedure, public :: siz => geom_siz private function geom_siz(this) result(siz) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(in) :: this Return Value integer procedure, public :: has_exc => geom_has_exc private function geom_has_exc(this) result(has_exc) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(in) :: this Return Value logical procedure, public :: clock => geom_clock private subroutine geom_clock(this, id) Arguments Type Intent Optional Attributes Name class( geom_t ), intent(inout) :: this integer, intent(in) :: id","tags":"","loc":"type/geom_t.html"},{"title":"ts_energy – Libmbd","text":"public function ts_energy(geom, alpha_0, C6, damp) result(ene) Get TS energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp Return Value real(kind=dp) Contents None","tags":"","loc":"proc/ts_energy.html"},{"title":"get_mbd_energy – Libmbd","text":"public function get_mbd_energy(geom, alpha_0, C6, damp, dene, grad) result(res) Get MBD energy. For a nonperiodic system, the method just transforms C_6 coefficients\n to frequencies, and performs a single call to get_mbd_hamiltonian_energy . For a periodic system, the method\n integrates the energy over the frist Brillouin zone. E=\\int_\\text{FBZ}\\mathrm d\\mathbf q\\,E(\\mathbf\n q)\\approx\\frac1{N_k}\\sum_i&#94;{N_k}E(\\mathbf q_i)\n \\\\ \\mathbf q_i=\\boldsymbol{\\mathcal B}\\mathbf n_i,\\qquad\\partial\\mathbf\n q_i=-\\big((\\partial\\boldsymbol{\\mathcal\n A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf q_i Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) Contents None","tags":"","loc":"proc/get_mbd_energy.html"},{"title":"get_mbd_scs_energy – Libmbd","text":"public function get_mbd_scs_energy(geom, variant, alpha_0, C6, damp, dene, grad) result(res) Get screened MBD energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom character(len=*), intent(in) :: variant real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) Contents None","tags":"","loc":"proc/get_mbd_scs_energy.html"},{"title":"omega_qho – Libmbd","text":"public function omega_qho(C6, alpha, domega, grad) result(omega) \\omega=\\frac{4C_6}{3\\alpha_{0}&#94;2},\\qquad\n \\partial\\omega=\\omega\\left(\n \\frac{\\partial C_6}{C_6}-\\frac{2\\partial\\alpha_0}{\\alpha_0}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: C6 (:) real(kind=dp), intent(in) :: alpha (:) type( grad_t ), intent(out), optional :: domega type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(C6)) Contents None","tags":"","loc":"proc/omega_qho.html"},{"title":"alpha_dyn_qho – Libmbd","text":"public function alpha_dyn_qho(alpha_0, omega, freq, dalpha, grad) result(alpha) \\alpha(\\mathrm iu)=\\frac{\\alpha_0}{1+u&#94;2/\\omega&#94;2},\\qquad\n \\partial\\alpha(\\mathrm iu)=\\alpha(\\mathrm iu)\\left(\n \\frac{\\partial\\alpha_0}{\\alpha_0}+\n \\frac2\\omega\\frac{\\partial\\omega}{1+\\omega&#94;2/u&#94;2}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( quad_pt_t ), intent(in) :: freq (0:) type( grad_t ), intent(out), allocatable :: dalpha (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha_0),0:ubound(freq,1)) Contents None","tags":"","loc":"proc/alpha_dyn_qho.html"},{"title":"C6_from_alpha – Libmbd","text":"public function C6_from_alpha(alpha, freq, dC6_dalpha, grad) result(C6) \\bar C_6=\\frac3\\pi\\int_0&#94;\\infty\\mathrm du\\,\\bar\\alpha(u)&#94;2,\\qquad\n \\partial\\bar C_6=\\frac6\\pi\\int_0&#94;\\infty\\mathrm du\n \\bar\\alpha(u)\\partial\\bar\\alpha(u) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:,0:) type( quad_pt_t ), intent(in) :: freq (0:) real(kind=dp), intent(out), optional allocatable :: dC6_dalpha (:,:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha,1)) Contents None","tags":"","loc":"proc/c6_from_alpha.html"},{"title":"sigma_selfint – Libmbd","text":"public function sigma_selfint(alpha, dsigma_dalpha, grad) result(sigma) \\begin{gathered}\n \\sigma_i(u)=\\left(\\frac13\\sqrt{\\frac2\\pi}\\alpha_i(u)\\right)&#94;{\\frac13},\\qquad\n \\partial\\sigma_i=\\sigma_i\\frac{\\partial\\alpha_i}{3\\alpha_i}\n \\\\ \\sigma_{ij}(u)=\\sqrt{\\sigma_i(u)&#94;2+\\sigma_j(u)&#94;2},\\qquad\n \\partial\\sigma_{ij}=\n \\frac{\\sigma_i\\partial\\sigma_i+\\sigma_j\\partial\\sigma_j}{\\sigma_{ij}}\n \\end{gathered} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:) real(kind=dp), intent(out), optional allocatable :: dsigma_dalpha (:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha)) Contents None","tags":"","loc":"proc/sigma_selfint.html"},{"title":"scale_with_ratio – Libmbd","text":"public function scale_with_ratio(x, yp, y, q, dx, grad) result(xp) x'=x\\left(\\frac{y'}y\\right)&#94;q,\\qquad\n \\partial x'=x\\left(\n \\frac{\\partial x}x+\n q\\frac{\\partial y'}{y'}-\n q\\frac{\\partial y}{y}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: yp (:) real(kind=dp), intent(in) :: y (:) real(kind=dp), intent(in) :: q type( grad_t ), intent(out), optional :: dx type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(x)) Contents None","tags":"","loc":"proc/scale_with_ratio.html"},{"title":"T_bare – Libmbd","text":"public function T_bare(r, dT, grad) result(T) T_{ab}(\\mathbf r)=\\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac1r=\n \\frac{-3r_ar_b+r&#94;2\\delta_{ab}}{r&#94;5},\\qquad\n \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}=-3\\left(\n \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}+r_c\\delta_{ab}}{r&#94;5}-\n \\frac{5r_ar_br_c}{r&#94;7}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) type( grad_matrix_re_t ), intent(out), optional :: dT logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) Contents None","tags":"","loc":"proc/t_bare.html"},{"title":"B_erfc – Libmbd","text":"public function B_erfc(r, gamm, dB, grad) result(B) \\begin{aligned}\n B(R,\\gamma)\n &=\\operatorname{erfc}(\\gamma R)\n +\\frac{2\\gamma R}{\\sqrt\\pi}\\mathrm e&#94;{-(\\gamma R)&#94;2}\n \\\\ \\partial B(R,\\gamma)\n &=-\\frac4{\\sqrt\\pi}(\\gamma R)&#94;2\\mathrm e&#94;{-(\\gamma R)&#94;2}\n (R\\partial\\gamma+\\gamma\\partial R)\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dB type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) Contents None","tags":"","loc":"proc/b_erfc.html"},{"title":"C_erfc – Libmbd","text":"public function C_erfc(r, gamm, dC, grad) result(C) \\begin{aligned}\n C(r,\\gamma)\n &=3\\operatorname{erfc}(\\gamma R)\n +\\frac{2\\gamma R}{\\sqrt\\pi}(3+2(\\gamma R)&#94;2)\\mathrm e&#94;{-(\\gamma R)&#94;2}\n \\\\ \\partial C(R,\\gamma)\n &=-\\frac8{\\sqrt\\pi}(\\gamma R)&#94;4\\mathrm e&#94;{-(\\gamma R)&#94;2}\n (R\\partial\\gamma+\\gamma\\partial R)\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dC type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) Contents None","tags":"","loc":"proc/c_erfc.html"},{"title":"T_erfc – Libmbd","text":"public function T_erfc(r, gamm, dT, grad) result(T) T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma)\n =-3\\frac{r_ar_b}{r&#94;5}C(r,\\gamma)+\\frac{\\delta_{ab}}{r&#94;3}B(r,\\gamma) \\begin{aligned}\n \\frac{\\partial T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma)}{\\partial r_c}\n &=-\\left(\n \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}}{r&#94;5}-\n 5\\frac{r_ar_br_c}{r&#94;7}\n \\right)C(r,\\gamma)-3\\frac{r_c\\delta_{ab}}{r&#94;5}B(r,\\gamma)\n \\\\ &-\\frac{r_ar_br_c}{r&#94;6}\\frac{\\partial C(r,\\gamma)}{\\partial\n r}+\\frac{r_c\\delta_{ab}}{r&#94;4}\\frac{\\partial B(r,\\gamma)}{\\partial r}\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: gamm type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) Contents None","tags":"","loc":"proc/t_erfc.html"},{"title":"T_erf_coulomb – Libmbd","text":"public function T_erf_coulomb(r, sigma, dT, grad) result(T) \\begin{aligned}\n T&#94;\\text{GG}_{ab}(\\mathbf r,\\sigma)&=\n \\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac{\\operatorname{erf}(\\zeta)}r=\n \\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big)T_{ab}(\\mathbf r)+\n 2\\zeta&#94;2\\Theta(\\zeta)\\frac{r_ar_b}{r&#94;5}\n \\\\ \\Theta(\\zeta)&=\\frac{2\\zeta}{\\sqrt\\pi}\\exp(-\\zeta&#94;2),\\qquad\n \\zeta=\\frac r\\sigma\n \\\\ \\frac{\\mathrm d T_{ab}&#94;\\text{GG}(\\mathbf r,\\sigma)}{\\mathrm dr_c}&=\n 2\\zeta\\Theta(\\zeta)\\left(T_{ab}(\\mathbf r)+(3-2\\zeta&#94;2)\\frac{r_ar_b}{r&#94;5}\\right)\n \\frac{\\mathrm d\\zeta}{\\mathrm dr_c}\n \\\\ &+\\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big)\n \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}-\n 2\\zeta&#94;2\\Theta(\\zeta)\\left(\n \\frac13\\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}+\n \\frac{r_c\\delta_{ab}}{r&#94;5}\n \\right)\n \\\\ \\qquad\\frac{\\mathrm d\\zeta}{\\mathrm dr_c}&=\n \\frac{r_c}{r\\sigma}-\\frac r{\\sigma&#94;2}\\frac{\\mathrm d\\sigma}{\\mathrm dr_c}\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: sigma type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) Contents None","tags":"","loc":"proc/t_erf_coulomb.html"},{"title":"dipole_matrix – Libmbd","text":"public interface dipole_matrix Form either a real or a complex dipole matrix. The real-typed version is equivalent to \\mathbf q=0 . \\boldsymbol{\\mathcal A}:=[\\mathbf a_1\\mathbf a_2\\mathbf\n a_3],\\qquad\\boldsymbol{\\mathcal B}:=[\\mathbf b_1\\mathbf b_2\\mathbf b_3]\n \\\\ \\boldsymbol{\\mathcal B}=2\\pi(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm\n T,\\qquad \\partial\\boldsymbol{\\mathcal B}=-\\big((\\partial\\boldsymbol{\\mathcal\n A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\boldsymbol{\\mathcal B}\n \\\\ \\mathbf R_\\mathbf n=\\boldsymbol{\\mathcal A}\\mathbf\n n,\\qquad\\partial\\mathbf R_\\mathbf n=(\\partial\\boldsymbol{\\mathcal\n A})\\mathbf n,\n \\\\ \\mathbf G_\\mathbf m=\\boldsymbol{\\mathcal B}\\mathbf m,\\qquad\n \\partial\\mathbf G_\\mathbf m=-\\big((\\partial\\boldsymbol{\\mathcal\n A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf G_\\mathbf m,\n \\\\ \\frac{\\partial G_{\\mathbf ma}}{\\partial A_{bc}}=-\\mathcal A&#94;{-1}_{ca}G_{\\mathbf mb} \\begin{gathered}\n \\mathbf T_{ij}(\\mathbf q)=\\sum_{\\mathbf n}\\mathbf T(\\mathbf R_{\\mathbf\n nij})\\mathrm e&#94;{-\\mathrm i\\mathbf q\\cdot\\mathbf R_{\\mathbf nij}},\\quad\\mathbf\n R_{\\mathbf nij}=\\mathbf R_j+\\mathbf R_\\mathbf n-\\mathbf R_i\n \\\\ \\frac{\\mathrm d\\mathbf R_{\\mathbf nij}}{\\mathrm d\\mathbf\n R_k}=(\\delta_{jk}-\\delta_{ik})\\mathbf I\n \\\\ \\mathbf{T}_{ij}(\\mathbf{q})\\approx\\mathbf{T}&#94;\\text{Ew}_{ij}(\\mathbf{q})\n =\\sum_\\mathbf n&#94;{|\\mathbf R_{\\mathbf nij}|<R_\\text c}\\mathbf\n T&#94;\\text{erfc}(\\mathbf R_{\\mathbf nij};\\gamma)\\mathrm e&#94;{-\\mathrm i\\mathbf\n q\\cdot\\mathbf R_{\\mathbf nij}} +\\frac{4\\pi}{V_\\text{uc}}\\sum_{\\mathbf\n m}&#94;{0<|\\mathbf k_\\mathbf m|<k_\\text c}\\mathbf{\\hat k}_\\mathbf\n m\\otimes\\mathbf{\\hat k}_\\mathbf m\\,\\mathrm e&#94;{-\\frac{k_\\mathbf\n m&#94;2}{4\\gamma&#94;2}-\\mathrm i\\mathbf G_\\mathbf m\\cdot\\mathbf R_{ij}}\n \\\\ -\\frac{4\\gamma&#94;3}{3\\sqrt\\pi}\\delta_{ij}\\mathbf I +\\delta(\\mathbf q)\\frac{4\n \\pi}{3 V_\\text{uc}}\\mathbf I,\\qquad \\mathbf k_\\mathbf m=\\mathbf G_\\mathbf\n m+\\mathbf q\n \\end{gathered} \\partial\\left(\\frac{4\\pi}{V_\\text{uc}}\\right)=-\\frac{4\\pi}{V_\\text{uc}}\\frac{\\partial\n V_\\text{uc}}{V_\\text{uc}},\\qquad\\frac{\\partial\n V_\\text{uc}}{\\partial\\boldsymbol{\\mathcal\n A}}=V_\\text{uc}(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm T\n \\\\ \\partial(k&#94;2)=2\\mathbf k\\cdot\\partial\\mathbf k\n \\\\ \\mathbf{\\hat k}\\otimes\\partial\\mathbf{\\hat k}=\\frac{\\mathbf\n k\\otimes\\partial\\mathbf k}{k&#94;2}-\\frac{\\mathbf k\\otimes\\mathbf\n k}{2k&#94;4}\\partial(k&#94;2) \\gamma:=\\frac{2.5}{\\sqrt[3]{V_\\text{uc}}},\\quad R_\\text\n c:=\\frac6\\gamma,\\quad k_\\text c:=10\\gamma Contents Module Procedures dipole_matrix_real dipole_matrix_complex Module Procedures private function dipole_matrix_real(geom, damp, ddipmat, grad) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_re_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad Return Value type(matrix_re_t) private function dipole_matrix_complex(geom, damp, ddipmat, grad, q) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_cplx_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad real(kind=dp), intent(in) :: q (3) Return Value type(matrix_cplx_t)","tags":"","loc":"interface/dipole_matrix.html"},{"title":"damping_fermi – Libmbd","text":"public function damping_fermi(r, s_vdw, d, df, grad) result(f) \\begin{gathered}\n f_{(ij)}=\\frac1{1+\\exp\\big({-}a(\\eta-1)\\big)},\\qquad\n \\eta=\\frac{R_{(ij)}}{S_{\\text{vdW}(ij)}}\\equiv\n \\frac{R_{(ij)}}{\\beta R_{\\text{vdW}(ij)}}\n \\\\ \\frac{\\mathrm df}{\\mathrm dR_c}=\n \\frac a{2+2\\cosh\\big(a(\\eta-1)\\big)}\\frac{\\mathrm d\\eta}{\\mathrm dR_c},\\qquad\n \\frac{\\mathrm d\\eta}{\\mathrm dR_c}=\n \\frac{R_c}{RS_\\text{vdW}}-\n \\frac{R}{S_\\text{vdW}&#94;2}\\frac{\\mathrm dS_\\text{vdW}}{\\mathrm dR_c}\n \\end{gathered} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: s_vdw real(kind=dp), intent(in) :: d type( grad_scalar_t ), intent(out), optional :: df type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) Contents None","tags":"","loc":"proc/damping_fermi.html"},{"title":"run_scs – Libmbd","text":"public function run_scs(geom, alpha, damp, dalpha_scs, grad) result(alpha_scs) \\begin{gathered}\n \\bar\\alpha_i=\\tfrac13\\operatorname{Tr}\n \\big(\\textstyle\\sum_j\\boldsymbol{\\bar\\alpha}_{ij}\\big),\\qquad\n \\boldsymbol{\\bar\\alpha}=(\\boldsymbol\\alpha&#94;{-1}+\\mathbf T_\\text{GG})&#94;{-1}\n \\\\ \\partial\\boldsymbol{\\bar\\alpha}=\n -\\boldsymbol{\\bar\\alpha}(\n \\partial\\boldsymbol\\alpha&#94;{-1}+\\partial\\mathbf T_\\text{GG}\n )\\boldsymbol{\\bar\\alpha},\\qquad\n \\frac{\\partial\\bar\\alpha_i}{\\partial X_j}=\n -\\frac13\\sum_{\\zeta\\eta}\\big(\n B_{i\\zeta,j\\eta}\\bar\\alpha'_{\\zeta,j\\eta}+\n B'_{j\\eta,\\zeta}\\bar\\alpha_{j\\eta,i\\zeta}\n \\big)\n \\\\ \\mathbf B=\\boldsymbol{\\bar\\alpha}\\mathbf A,\n \\quad A_{i\\zeta,j\\eta}=\n \\frac{\\partial(\\alpha_i&#94;{-1})}{\\partial X_i}\n \\delta_{ij}\\delta_{\\zeta\\eta}+\n \\frac{\\partial T&#94;\\text{GG}_{i\\zeta,j\\eta}}{\\partial X_i},\\quad\n \\bar\\alpha'_{\\zeta,p}=\\sum_i\\bar\\alpha_{i\\zeta,p},\\quad\n B'_{p,\\zeta}=\\sum_iB_{p,i\\zeta}\n \\end{gathered} Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dalpha_scs (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha)) Contents None","tags":"","loc":"proc/run_scs.html"},{"title":"get_mbd_hamiltonian_energy – Libmbd","text":"public interface get_mbd_hamiltonian_energy Form and solve either a real or a complex MBD Hamiltonian. The real-typed version is equivalent to \\mathbf q=0 . \\begin{gathered}\n E_\\text{MBD}(\\mathbf q)=\\frac12\\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf\n q)}\\big)- 3\\sum_i\\frac{\\omega_i}2,\\qquad\n \\mathbf Q_{ij}(\\mathbf q)=\\omega_i&#94;2\\delta_{ij}\\mathbf I+\n \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}(\\mathbf q)\n \\\\ \\mathbf Q(\\mathbf q)\\equiv\n \\mathbf C(\\mathbf q)\\boldsymbol\\Lambda(\\mathbf q)\\mathbf C(\\mathbf\n q)&#94;\\dagger,\\qquad\n \\boldsymbol\\Lambda(\\mathbf q)\n \\equiv\\operatorname{diag}(\\{\\tilde\\omega_i(\\mathbf q)&#94;2\\}),\\qquad\n \\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf q)}\\big)\n =\\sum_i\\tilde\\omega_i(\\mathbf q)\n \\end{gathered} \\begin{aligned}\n \\partial E_\\text{MBD}&=\\frac14\\operatorname{Tr}\\big(\n \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger\n \\partial\\mathbf Q\n \\big)-\n 3\\sum_i\\frac{\\partial\\omega_i}2\n \\\\ \\frac{\\partial E_\\text{MBD}}{\\partial X_i}&=\n \\operatorname{Re}\\frac12\\sum_{p\\zeta}(\n \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger\n )_{i\\zeta,p}\n \\frac{\\partial Q_{p,i\\zeta}}{\\partial X_i}-\n \\frac32\\frac{\\partial\\omega_i}{\\partial X_i}\n \\end{aligned} \\begin{aligned}\n \\partial\\mathbf Q_{ij}=&\n 2\\delta_{ij}\\omega_i\\partial\\omega_i\\mathbf I+\n \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}\\left(\n \\frac{\\partial\\omega_i}{\\omega_i}+\n \\frac{\\partial\\omega_j}{\\omega_j}+\n \\frac12\\frac{\\partial\\alpha_{0,i}}{\\alpha_{0,i}}+\n \\frac12\\frac{\\partial\\alpha_{0,j}}{\\alpha_{0,j}}\n \\right)\n \\\\ &+\\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\n \\partial\\mathbf T_{ij}\n \\end{aligned} Contents Module Procedures get_mbd_hamiltonian_energy_real get_mbd_hamiltonian_energy_complex Module Procedures private function get_mbd_hamiltonian_energy_real(geom, alpha_0, omega, damp, dene, grad) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) private function get_mbd_hamiltonian_energy_complex(geom, alpha_0, omega, damp, dene, grad, q) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad real(kind=dp), intent(in) :: q (3) Return Value type( result_t )","tags":"","loc":"interface/get_mbd_hamiltonian_energy.html"},{"title":"mbd_ts – Libmbd","text":"Obtaining TS energies. Uses mbd_constants mbd_utils mbd_damping mbd_geom Contents Functions ts_energy Functions public function ts_energy (geom, alpha_0, C6, damp) result(ene) Get TS energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp Return Value real(kind=dp)","tags":"","loc":"module/mbd_ts.html"},{"title":"mbd – Libmbd","text":"High-level Fortran API. Uses mbd_constants mbd_damping mbd_formulas mbd_geom mbd_gradients mbd_methods mbd_ts mbd_utils mbd_vdw_param Contents Derived Types mbd_input_t mbd_calc_t Derived Types type, public :: mbd_input_t Contains user input to an MBD calculation. Components Type Visibility Attributes Name Initial character(len=30), public :: method = 'mbd-rsscs' VdW method to use to calculate energy and gradients. mbd-rsscs : The MBD@rsSCS method. mbd-nl : The MBD-NL method. ts : The TS method. mbd : Generic MBD method (without any screening). integer, public :: comm = -1 MPI communicator. Only used when compiled with MPI. Leave as is to use the\n MPI_COMM_WORLD communicator. logical, public :: calculate_forces = .true. Whether to calculate forces. logical, public :: calculate_spectrum = .false. Whether to keep MBD eigenvalues. real(kind=dp), public :: ts_ene_acc = 1d-6 Required accuracy of the TS energy. real(kind=dp), public :: ts_f_acc = 1d-7 Required accuracy of the TS gradients. integer, public :: n_omega_grid = 15 Number of imaginary frequency grid points. real(kind=dp), public :: k_grid_shift = 0.5d0 Off- \\Gamma shift of the k -point grid in units of\n inter- k -point distance. logical, public :: zero_negative_eigvals = .false. Whether to zero out negative eigenvalues. character(len=20), public :: xc = '' XC functional for automatic setting of damping parameters. real(kind=dp), public :: ts_d = 20d0 TS damping parameter d . real(kind=dp), public :: ts_sr = -1 Custom TS damping parameter s_R . Leave as is to use a value based on the XC functional. real(kind=dp), public :: mbd_a = 6d0 MBD damping parameter a . real(kind=dp), public :: mbd_beta = -1 Custom MBD damping parameter \\beta . Leave as is to use a value based on the XC functional. character(len=10), public :: vdw_params_kind = 'ts' Which free-atom reference vdW parameters to use for scaling. ts : Values from original TS method. tssurf : Values from the TS &#94;\\text{surf} approach. character(len=3), public, allocatable :: atom_types (:) ( N ) Atom types used for picking free-atom reference values. real(kind=dp), public, allocatable :: free_values (:,:) ( N\\times3 , a.u.) Custom free-atom vdW paramters to use for\n scaling. Columns contain static polarizabilities, C6 coefficients, and vdW\n radii. real(kind=dp), public, allocatable :: coords (:,:) ( 3\\times N , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice_vectors (:,:) ( 3\\times 3 , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public :: k_grid (3) = [-1, -1, -1] Number of k -points along reciprocal axes. character(len=10), public :: parallel_mode = 'auto' Parallelization scheme. auto : Pick based on system system size and number of k -points. kpoints : Parallelize over k -points. atoms : Parallelize over atom pairs. type, public :: mbd_calc_t Represents an MBD calculation. Type-Bound Procedures procedure, public :: init => mbd_calc_init procedure, public :: destroy => mbd_calc_destroy procedure, public :: update_coords => mbd_calc_update_coords procedure, public :: update_lattice_vectors => mbd_calc_update_lattice_vectors procedure, public :: update_vdw_params_custom => mbd_calc_update_vdw_params_custom procedure, public :: update_vdw_params_from_ratios => mbd_calc_update_vdw_params_from_ratios procedure, public :: update_vdw_params_nl => mbd_calc_update_vdw_params_nl procedure, public :: evaluate_vdw_method => mbd_calc_evaluate_vdw_method procedure, public :: get_gradients => mbd_calc_get_gradients procedure, public :: get_lattice_derivs => mbd_calc_get_lattice_derivs procedure, public :: get_spectrum_modes => mbd_calc_get_spectrum_modes procedure, public :: get_exception => mbd_calc_get_exception","tags":"","loc":"module/mbd.html"},{"title":"mbd_constants – Libmbd","text":"Constants used throughout. Contents Variables ang MBD_EXC_NEG_EIGVALS MBD_EXC_NEG_POL MBD_EXC_LINALG MBD_EXC_UNIMPL MBD_EXC_DAMPING MBD_EXC_INPUT Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: ang = 1.8897259886d0 Value of angstrom in atomic units integer, public, parameter :: MBD_EXC_NEG_EIGVALS = 1 Negative eigenvalue exception integer, public, parameter :: MBD_EXC_NEG_POL = 2 Negative polarizability exception integer, public, parameter :: MBD_EXC_LINALG = 3 Exception in LAPACK or ScaLAPACK integer, public, parameter :: MBD_EXC_UNIMPL = 4 Functionality is not implemented integer, public, parameter :: MBD_EXC_DAMPING = 5 Damping-function exception integer, public, parameter :: MBD_EXC_INPUT = 6 Invalid input","tags":"","loc":"module/mbd_constants.html"},{"title":"mbd_gradients – Libmbd","text":"Derivatives. Uses mbd_constants Contents Derived Types grad_t grad_matrix_re_t grad_matrix_cplx_t grad_scalar_t grad_request_t Derived Types type, public :: grad_t Derivatives with respect to various quantities Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dcoords (:,:) real(kind=dp), public, allocatable :: dlattice (:,:) real(kind=dp), public, allocatable :: dalpha (:) real(kind=dp), public, allocatable :: dalpha_dyn (:,:) real(kind=dp), public, allocatable :: dC6 (:) real(kind=dp), public, allocatable :: dq (:) real(kind=dp), public, allocatable :: dr_vdw (:) real(kind=dp), public, allocatable :: domega (:) real(kind=dp), public, allocatable :: dV (:) real(kind=dp), public, allocatable :: dV_free (:) real(kind=dp), public, allocatable :: dX_free (:) type, public :: grad_matrix_re_t Derivatives of a real dipole matrix with respect to various quantities Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:,:,:) real(kind=dp), public, allocatable :: dlattice (:,:,:,:) real(kind=dp), public, allocatable :: dvdw (:,:) real(kind=dp), public, allocatable :: dsigma (:,:) real(kind=dp), public, allocatable :: dgamma (:,:) type, public :: grad_matrix_cplx_t Derivatives of a compelx dipole matrix with respect to various quantities Components Type Visibility Attributes Name Initial complex(kind=dp), public, allocatable :: dr (:,:,:) complex(kind=dp), public, allocatable :: dlattice (:,:,:,:) complex(kind=dp), public, allocatable :: dq (:,:,:) complex(kind=dp), public, allocatable :: dvdw (:,:) complex(kind=dp), public, allocatable :: dsigma (:,:) complex(kind=dp), public, allocatable :: dgamma (:,:) type, public :: grad_scalar_t Derivatives of a scalar with respect to various quantities Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dr (:) real(kind=dp), public, allocatable :: dr_1 real(kind=dp), public, allocatable :: dvdw real(kind=dp), public, allocatable :: dgamma type, public :: grad_request_t Used to request derivatives with respect to function arguments Components Type Visibility Attributes Name Initial logical, public :: dcoords = .false. logical, public :: dalpha = .false. logical, public :: dalpha_dyn = .false. logical, public :: dC6 = .false. logical, public :: dr_vdw = .false. logical, public :: domega = .false. logical, public :: dsigma = .false. logical, public :: dgamma = .false. logical, public :: dq = .false. logical, public :: dlattice = .false. logical, public :: dV = .false. logical, public :: dV_free = .false. logical, public :: dX_free = .false. Type-Bound Procedures procedure, public :: any => grad_request_any","tags":"","loc":"module/mbd_gradients.html"},{"title":"mbd_elsi – Libmbd","text":"Uses elsi mbd_constants mbd_blacs mbd_utils Contents None","tags":"","loc":"module/mbd_elsi.html"},{"title":"mbd_methods – Libmbd","text":"Obtaining MBD energies. Uses mbd_constants mbd_damping mbd_formulas mbd_geom mbd_gradients mbd_hamiltonian mbd_lapack mbd_rpa mbd_scs mbd_utils mbd_blacs Contents Functions get_mbd_energy get_mbd_scs_energy Functions public function get_mbd_energy (geom, alpha_0, C6, damp, dene, grad) result(res) Get MBD energy. For a nonperiodic system, the method just transforms C_6 coefficients\n to frequencies, and performs a single call to get_mbd_hamiltonian_energy . For a periodic system, the method\n integrates the energy over the frist Brillouin zone. E=\\int_\\text{FBZ}\\mathrm d\\mathbf q\\,E(\\mathbf\n q)\\approx\\frac1{N_k}\\sum_i&#94;{N_k}E(\\mathbf q_i)\n \\\\ \\mathbf q_i=\\boldsymbol{\\mathcal B}\\mathbf n_i,\\qquad\\partial\\mathbf\n q_i=-\\big((\\partial\\boldsymbol{\\mathcal\n A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf q_i Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) public function get_mbd_scs_energy (geom, variant, alpha_0, C6, damp, dene, grad) result(res) Get screened MBD energy. Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom character(len=*), intent(in) :: variant real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: C6 (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad Return Value type( result_t )","tags":"","loc":"module/mbd_methods.html"},{"title":"mbd_formulas – Libmbd","text":"Common formulas used at multiple places. Uses mbd_constants mbd_gradients mbd_utils Contents Functions omega_qho alpha_dyn_qho C6_from_alpha sigma_selfint scale_with_ratio Functions public function omega_qho (C6, alpha, domega, grad) result(omega) \\omega=\\frac{4C_6}{3\\alpha_{0}&#94;2},\\qquad\n \\partial\\omega=\\omega\\left(\n \\frac{\\partial C_6}{C_6}-\\frac{2\\partial\\alpha_0}{\\alpha_0}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: C6 (:) real(kind=dp), intent(in) :: alpha (:) type( grad_t ), intent(out), optional :: domega type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(C6)) public function alpha_dyn_qho (alpha_0, omega, freq, dalpha, grad) result(alpha) \\alpha(\\mathrm iu)=\\frac{\\alpha_0}{1+u&#94;2/\\omega&#94;2},\\qquad\n \\partial\\alpha(\\mathrm iu)=\\alpha(\\mathrm iu)\\left(\n \\frac{\\partial\\alpha_0}{\\alpha_0}+\n \\frac2\\omega\\frac{\\partial\\omega}{1+\\omega&#94;2/u&#94;2}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( quad_pt_t ), intent(in) :: freq (0:) type( grad_t ), intent(out), allocatable :: dalpha (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha_0),0:ubound(freq,1)) public function C6_from_alpha (alpha, freq, dC6_dalpha, grad) result(C6) \\bar C_6=\\frac3\\pi\\int_0&#94;\\infty\\mathrm du\\,\\bar\\alpha(u)&#94;2,\\qquad\n \\partial\\bar C_6=\\frac6\\pi\\int_0&#94;\\infty\\mathrm du\n \\bar\\alpha(u)\\partial\\bar\\alpha(u) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:,0:) type( quad_pt_t ), intent(in) :: freq (0:) real(kind=dp), intent(out), optional allocatable :: dC6_dalpha (:,:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha,1)) public function sigma_selfint (alpha, dsigma_dalpha, grad) result(sigma) \\begin{gathered}\n \\sigma_i(u)=\\left(\\frac13\\sqrt{\\frac2\\pi}\\alpha_i(u)\\right)&#94;{\\frac13},\\qquad\n \\partial\\sigma_i=\\sigma_i\\frac{\\partial\\alpha_i}{3\\alpha_i}\n \\\\ \\sigma_{ij}(u)=\\sqrt{\\sigma_i(u)&#94;2+\\sigma_j(u)&#94;2},\\qquad\n \\partial\\sigma_{ij}=\n \\frac{\\sigma_i\\partial\\sigma_i+\\sigma_j\\partial\\sigma_j}{\\sigma_{ij}}\n \\end{gathered} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha (:) real(kind=dp), intent(out), optional allocatable :: dsigma_dalpha (:) logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (size(alpha)) public function scale_with_ratio (x, yp, y, q, dx, grad) result(xp) x'=x\\left(\\frac{y'}y\\right)&#94;q,\\qquad\n \\partial x'=x\\left(\n \\frac{\\partial x}x+\n q\\frac{\\partial y'}{y'}-\n q\\frac{\\partial y}{y}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: yp (:) real(kind=dp), intent(in) :: y (:) real(kind=dp), intent(in) :: q type( grad_t ), intent(out), optional :: dx type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (size(x))","tags":"","loc":"module/mbd_formulas.html"},{"title":"mbd_dipole – Libmbd","text":"Construction of dipole tensors and dipole matrices. Uses mbd_constants mbd_matrix mbd_geom mbd_damping mbd_gradients mbd_lapack mbd_linalg mbd_utils Contents Interfaces dipole_matrix Functions T_bare B_erfc C_erfc T_erfc T_erf_coulomb Interfaces public interface dipole_matrix Form either a real or a complex dipole matrix. The real-typed version is equivalent to \\mathbf q=0 . \\boldsymbol{\\mathcal A}:=[\\mathbf a_1\\mathbf a_2\\mathbf\n a_3],\\qquad\\boldsymbol{\\mathcal B}:=[\\mathbf b_1\\mathbf b_2\\mathbf b_3]\n \\\\ \\boldsymbol{\\mathcal B}=2\\pi(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm\n T,\\qquad \\partial\\boldsymbol{\\mathcal B}=-\\big((\\partial\\boldsymbol{\\mathcal\n A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\boldsymbol{\\mathcal B}\n \\\\ \\mathbf R_\\mathbf n=\\boldsymbol{\\mathcal A}\\mathbf\n n,\\qquad\\partial\\mathbf R_\\mathbf n=(\\partial\\boldsymbol{\\mathcal\n A})\\mathbf n,\n \\\\ \\mathbf G_\\mathbf m=\\boldsymbol{\\mathcal B}\\mathbf m,\\qquad\n \\partial\\mathbf G_\\mathbf m=-\\big((\\partial\\boldsymbol{\\mathcal\n A})\\boldsymbol{\\mathcal A}&#94;{-1}\\big)&#94;\\mathrm T\\mathbf G_\\mathbf m,\n \\\\ \\frac{\\partial G_{\\mathbf ma}}{\\partial A_{bc}}=-\\mathcal A&#94;{-1}_{ca}G_{\\mathbf mb} \\begin{gathered}\n \\mathbf T_{ij}(\\mathbf q)=\\sum_{\\mathbf n}\\mathbf T(\\mathbf R_{\\mathbf\n nij})\\mathrm e&#94;{-\\mathrm i\\mathbf q\\cdot\\mathbf R_{\\mathbf nij}},\\quad\\mathbf\n R_{\\mathbf nij}=\\mathbf R_j+\\mathbf R_\\mathbf n-\\mathbf R_i\n \\\\ \\frac{\\mathrm d\\mathbf R_{\\mathbf nij}}{\\mathrm d\\mathbf\n R_k}=(\\delta_{jk}-\\delta_{ik})\\mathbf I\n \\\\ \\mathbf{T}_{ij}(\\mathbf{q})\\approx\\mathbf{T}&#94;\\text{Ew}_{ij}(\\mathbf{q})\n =\\sum_\\mathbf n&#94;{|\\mathbf R_{\\mathbf nij}|<R_\\text c}\\mathbf\n T&#94;\\text{erfc}(\\mathbf R_{\\mathbf nij};\\gamma)\\mathrm e&#94;{-\\mathrm i\\mathbf\n q\\cdot\\mathbf R_{\\mathbf nij}} +\\frac{4\\pi}{V_\\text{uc}}\\sum_{\\mathbf\n m}&#94;{0<|\\mathbf k_\\mathbf m|<k_\\text c}\\mathbf{\\hat k}_\\mathbf\n m\\otimes\\mathbf{\\hat k}_\\mathbf m\\,\\mathrm e&#94;{-\\frac{k_\\mathbf\n m&#94;2}{4\\gamma&#94;2}-\\mathrm i\\mathbf G_\\mathbf m\\cdot\\mathbf R_{ij}}\n \\\\ -\\frac{4\\gamma&#94;3}{3\\sqrt\\pi}\\delta_{ij}\\mathbf I +\\delta(\\mathbf q)\\frac{4\n \\pi}{3 V_\\text{uc}}\\mathbf I,\\qquad \\mathbf k_\\mathbf m=\\mathbf G_\\mathbf\n m+\\mathbf q\n \\end{gathered} \\partial\\left(\\frac{4\\pi}{V_\\text{uc}}\\right)=-\\frac{4\\pi}{V_\\text{uc}}\\frac{\\partial\n V_\\text{uc}}{V_\\text{uc}},\\qquad\\frac{\\partial\n V_\\text{uc}}{\\partial\\boldsymbol{\\mathcal\n A}}=V_\\text{uc}(\\boldsymbol{\\mathcal A}&#94;{-1})&#94;\\mathrm T\n \\\\ \\partial(k&#94;2)=2\\mathbf k\\cdot\\partial\\mathbf k\n \\\\ \\mathbf{\\hat k}\\otimes\\partial\\mathbf{\\hat k}=\\frac{\\mathbf\n k\\otimes\\partial\\mathbf k}{k&#94;2}-\\frac{\\mathbf k\\otimes\\mathbf\n k}{2k&#94;4}\\partial(k&#94;2) \\gamma:=\\frac{2.5}{\\sqrt[3]{V_\\text{uc}}},\\quad R_\\text\n c:=\\frac6\\gamma,\\quad k_\\text c:=10\\gamma private function dipole_matrix_real(geom, damp, ddipmat, grad) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_re_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad Return Value type(matrix_re_t) private function dipole_matrix_complex(geom, damp, ddipmat, grad, q) result(dipmat) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom type( damping_t ), intent(in) :: damp type( grad_matrix_cplx_t ), intent(out), optional :: ddipmat type( grad_request_t ), intent(in), optional :: grad real(kind=dp), intent(in) :: q (3) Return Value type(matrix_cplx_t) Functions public function T_bare (r, dT, grad) result(T) T_{ab}(\\mathbf r)=\\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac1r=\n \\frac{-3r_ar_b+r&#94;2\\delta_{ab}}{r&#94;5},\\qquad\n \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}=-3\\left(\n \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}+r_c\\delta_{ab}}{r&#94;5}-\n \\frac{5r_ar_br_c}{r&#94;7}\n \\right) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) type( grad_matrix_re_t ), intent(out), optional :: dT logical, intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) public function B_erfc (r, gamm, dB, grad) result(B) \\begin{aligned}\n B(R,\\gamma)\n &=\\operatorname{erfc}(\\gamma R)\n +\\frac{2\\gamma R}{\\sqrt\\pi}\\mathrm e&#94;{-(\\gamma R)&#94;2}\n \\\\ \\partial B(R,\\gamma)\n &=-\\frac4{\\sqrt\\pi}(\\gamma R)&#94;2\\mathrm e&#94;{-(\\gamma R)&#94;2}\n (R\\partial\\gamma+\\gamma\\partial R)\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dB type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) public function C_erfc (r, gamm, dC, grad) result(C) \\begin{aligned}\n C(r,\\gamma)\n &=3\\operatorname{erfc}(\\gamma R)\n +\\frac{2\\gamma R}{\\sqrt\\pi}(3+2(\\gamma R)&#94;2)\\mathrm e&#94;{-(\\gamma R)&#94;2}\n \\\\ \\partial C(R,\\gamma)\n &=-\\frac8{\\sqrt\\pi}(\\gamma R)&#94;4\\mathrm e&#94;{-(\\gamma R)&#94;2}\n (R\\partial\\gamma+\\gamma\\partial R)\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r real(kind=dp), intent(in) :: gamm type( grad_scalar_t ), intent(out), optional :: dC type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp) public function T_erfc (r, gamm, dT, grad) result(T) T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma)\n =-3\\frac{r_ar_b}{r&#94;5}C(r,\\gamma)+\\frac{\\delta_{ab}}{r&#94;3}B(r,\\gamma) \\begin{aligned}\n \\frac{\\partial T_{ab}&#94;\\text{erfc}(\\mathbf r,\\gamma)}{\\partial r_c}\n &=-\\left(\n \\frac{r_a\\delta_{bc}+r_b\\delta_{ca}}{r&#94;5}-\n 5\\frac{r_ar_br_c}{r&#94;7}\n \\right)C(r,\\gamma)-3\\frac{r_c\\delta_{ab}}{r&#94;5}B(r,\\gamma)\n \\\\ &-\\frac{r_ar_br_c}{r&#94;6}\\frac{\\partial C(r,\\gamma)}{\\partial\n r}+\\frac{r_c\\delta_{ab}}{r&#94;4}\\frac{\\partial B(r,\\gamma)}{\\partial r}\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: gamm type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3) public function T_erf_coulomb (r, sigma, dT, grad) result(T) \\begin{aligned}\n T&#94;\\text{GG}_{ab}(\\mathbf r,\\sigma)&=\n \\frac{\\partial&#94;2}{\\partial r_a\\partial r_b}\\frac{\\operatorname{erf}(\\zeta)}r=\n \\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big)T_{ab}(\\mathbf r)+\n 2\\zeta&#94;2\\Theta(\\zeta)\\frac{r_ar_b}{r&#94;5}\n \\\\ \\Theta(\\zeta)&=\\frac{2\\zeta}{\\sqrt\\pi}\\exp(-\\zeta&#94;2),\\qquad\n \\zeta=\\frac r\\sigma\n \\\\ \\frac{\\mathrm d T_{ab}&#94;\\text{GG}(\\mathbf r,\\sigma)}{\\mathrm dr_c}&=\n 2\\zeta\\Theta(\\zeta)\\left(T_{ab}(\\mathbf r)+(3-2\\zeta&#94;2)\\frac{r_ar_b}{r&#94;5}\\right)\n \\frac{\\mathrm d\\zeta}{\\mathrm dr_c}\n \\\\ &+\\big(\\operatorname{erf}(\\zeta)-\\Theta(\\zeta)\\big)\n \\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}-\n 2\\zeta&#94;2\\Theta(\\zeta)\\left(\n \\frac13\\frac{\\partial T_{ab}(\\mathbf r)}{\\partial r_c}+\n \\frac{r_c\\delta_{ab}}{r&#94;5}\n \\right)\n \\\\ \\qquad\\frac{\\mathrm d\\zeta}{\\mathrm dr_c}&=\n \\frac{r_c}{r\\sigma}-\\frac r{\\sigma&#94;2}\\frac{\\mathrm d\\sigma}{\\mathrm dr_c}\n \\end{aligned} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: sigma type( grad_matrix_re_t ), intent(out), optional :: dT type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)\n  (3,3)","tags":"","loc":"module/mbd_dipole.html"},{"title":"mbd_utils – Libmbd","text":"Utility types, interfaces, and procedures. Uses mbd_constants mbd_mpi Contents Derived Types exception_t result_t atom_index_t clock_t quad_pt_t Derived Types type, public :: exception_t Represents an exception. Components Type Visibility Attributes Name Initial integer, public :: code = 0 character(len=50), public :: origin = '(unknown)' character(len=150), public :: msg = '' type, public :: result_t Stores results from an MBD calculation Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy real(kind=dp), public, allocatable :: mode_eigs (:) real(kind=dp), public, allocatable :: modes (:,:) real(kind=dp), public, allocatable :: rpa_orders (:) real(kind=dp), public, allocatable :: mode_eigs_k (:,:) complex(kind=dp), public, allocatable :: modes_k (:,:,:) complex(kind=dp), public, allocatable :: modes_k_single (:,:) real(kind=dp), public, allocatable :: rpa_orders_k (:,:) type, public :: atom_index_t Maps from atom indexes to positions in matrices. Components Type Visibility Attributes Name Initial integer, public, allocatable :: i_atom (:) integer, public, allocatable :: j_atom (:) integer, public :: n_atoms logical, public :: parallel type, public :: clock_t Used for measuring performance. Components Type Visibility Attributes Name Initial logical, public :: active = .true. integer, public, allocatable :: timestamps (:) integer, public, allocatable :: counts (:) Type-Bound Procedures procedure, public :: init => clock_init procedure, public :: clock => clock_clock type, public :: quad_pt_t Represents a 1D quadrature point Components Type Visibility Attributes Name Initial real(kind=dp), public :: val real(kind=dp), public :: weight","tags":"","loc":"module/mbd_utils.html"},{"title":"mbd_damping – Libmbd","text":"Damping functions. Uses mbd_constants mbd_gradients mbd_utils Contents Derived Types damping_t Functions damping_fermi Derived Types type, public :: damping_t Represents a damping function. Components Type Visibility Attributes Name Initial character(len=20), public :: version real(kind=dp), public :: beta = 0d0 real(kind=dp), public :: a = 6d0 real(kind=dp), public :: ts_d = 20d0 real(kind=dp), public :: ts_sr = 0d0 real(kind=dp), public :: mayer_scaling = 1d0 real(kind=dp), public, allocatable :: r_vdw (:) real(kind=dp), public, allocatable :: sigma (:) real(kind=dp), public, allocatable :: damping_custom (:,:) real(kind=dp), public, allocatable :: potential_custom (:,:,:,:) Type-Bound Procedures procedure, public :: set_params_from_xc => damping_set_params_from_xc Functions public function damping_fermi (r, s_vdw, d, df, grad) result(f) \\begin{gathered}\n f_{(ij)}=\\frac1{1+\\exp\\big({-}a(\\eta-1)\\big)},\\qquad\n \\eta=\\frac{R_{(ij)}}{S_{\\text{vdW}(ij)}}\\equiv\n \\frac{R_{(ij)}}{\\beta R_{\\text{vdW}(ij)}}\n \\\\ \\frac{\\mathrm df}{\\mathrm dR_c}=\n \\frac a{2+2\\cosh\\big(a(\\eta-1)\\big)}\\frac{\\mathrm d\\eta}{\\mathrm dR_c},\\qquad\n \\frac{\\mathrm d\\eta}{\\mathrm dR_c}=\n \\frac{R_c}{RS_\\text{vdW}}-\n \\frac{R}{S_\\text{vdW}&#94;2}\\frac{\\mathrm dS_\\text{vdW}}{\\mathrm dR_c}\n \\end{gathered} Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r (3) real(kind=dp), intent(in) :: s_vdw real(kind=dp), intent(in) :: d type( grad_scalar_t ), intent(out), optional :: df type( grad_request_t ), intent(in), optional :: grad Return Value real(kind=dp)","tags":"","loc":"module/mbd_damping.html"},{"title":"mbd_scs – Libmbd","text":"Performing self-consistent screening. Uses mbd_constants mbd_damping mbd_dipole mbd_formulas mbd_geom mbd_gradients mbd_matrix mbd_utils Contents Functions run_scs Functions public function run_scs (geom, alpha, damp, dalpha_scs, grad) result(alpha_scs) \\begin{gathered}\n \\bar\\alpha_i=\\tfrac13\\operatorname{Tr}\n \\big(\\textstyle\\sum_j\\boldsymbol{\\bar\\alpha}_{ij}\\big),\\qquad\n \\boldsymbol{\\bar\\alpha}=(\\boldsymbol\\alpha&#94;{-1}+\\mathbf T_\\text{GG})&#94;{-1}\n \\\\ \\partial\\boldsymbol{\\bar\\alpha}=\n -\\boldsymbol{\\bar\\alpha}(\n \\partial\\boldsymbol\\alpha&#94;{-1}+\\partial\\mathbf T_\\text{GG}\n )\\boldsymbol{\\bar\\alpha},\\qquad\n \\frac{\\partial\\bar\\alpha_i}{\\partial X_j}=\n -\\frac13\\sum_{\\zeta\\eta}\\big(\n B_{i\\zeta,j\\eta}\\bar\\alpha'_{\\zeta,j\\eta}+\n B'_{j\\eta,\\zeta}\\bar\\alpha_{j\\eta,i\\zeta}\n \\big)\n \\\\ \\mathbf B=\\boldsymbol{\\bar\\alpha}\\mathbf A,\n \\quad A_{i\\zeta,j\\eta}=\n \\frac{\\partial(\\alpha_i&#94;{-1})}{\\partial X_i}\n \\delta_{ij}\\delta_{\\zeta\\eta}+\n \\frac{\\partial T&#94;\\text{GG}_{i\\zeta,j\\eta}}{\\partial X_i},\\quad\n \\bar\\alpha'_{\\zeta,p}=\\sum_i\\bar\\alpha_{i\\zeta,p},\\quad\n B'_{p,\\zeta}=\\sum_iB_{p,i\\zeta}\n \\end{gathered} Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dalpha_scs (:) type( grad_request_t ), intent(in) :: grad Return Value real(kind=dp)\n  (size(alpha))","tags":"","loc":"module/mbd_scs.html"},{"title":"mbd_geom – Libmbd","text":"Representing a molecule or a crystal unit cell. Uses mbd_constants mbd_lapack mbd_utils mbd_blacs mbd_mpi Contents Derived Types param_t geom_t Derived Types type, public :: param_t Calculation-wide paramters. Components Type Visibility Attributes Name Initial real(kind=dp), public :: ts_energy_accuracy = 1d-6 real(kind=dp), public :: ts_cutoff_radius = 50d0*ang real(kind=dp), public :: dipole_cutoff = 400d0*ang real(kind=dp), public :: ewald_real_cutoff_scaling = 1d0 real(kind=dp), public :: ewald_rec_cutoff_scaling = 1d0 real(kind=dp), public :: k_grid_shift = 0.5d0 logical, public :: ewald_on = .true. logical, public :: zero_negative_eigvals = .false. integer, public :: rpa_order_max = 10 integer, public :: n_freq = 15 type, public :: geom_t Represents a molecule or a crystal unit cell. The documented variables should be set before calling the initializer. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: coords (:,:) ( 3\\times N , a.u.) Atomic coordinates. real(kind=dp), public, allocatable :: lattice (:,:) ( 3\\times 3 , a.u.) Lattice vectors in columns, unallocated if not\n periodic. integer, public, allocatable :: k_grid (:) Number of k -points along reciprocal axes. character(len=10), public :: parallel_mode = 'auto' Type of parallelization: atoms : distribute matrices over all MPI tasks using ScaLAPACK,\n solve eigenproblems sequentialy. k_points : parallelize over k-points (each MPI task solves entire\n eigenproblems for its k-points) logical, public :: get_eigs = .false. Whether to keep MBD eigenvalues logical, public :: get_modes = .false. Whether to calculate MBD eigenvectors logical, public :: do_rpa = .false. Whether to calculate MBD energy by frequency integration logical, public :: get_rpa_orders = .false. Whether to calculate RPA orders type( clock_t ), public :: clock_ type( exception_t ), public :: exc logical, public :: muted = .false. type( quad_pt_t ), public, allocatable :: freq (:) real(kind=dp), public :: gamm = 0d0 real(kind=dp), public :: real_space_cutoff real(kind=dp), public :: rec_space_cutoff type( param_t ), public :: param type( atom_index_t ), public :: idx type(blacs_desc_t), public :: blacs type(blacs_grid_t), public :: blacs_grid integer, public :: comm = MPI_COMM_WORLD Type-Bound Procedures procedure, public :: init => geom_init procedure, public :: destroy => geom_destroy procedure, public :: siz => geom_siz procedure, public :: has_exc => geom_has_exc procedure, public :: clock => geom_clock","tags":"","loc":"module/mbd_geom.html"},{"title":"mbd_hamiltonian – Libmbd","text":"Forming and solving MBD Hamiltonian. Uses mbd_constants mbd_damping mbd_dipole mbd_geom mbd_gradients mbd_matrix mbd_utils Contents Interfaces get_mbd_hamiltonian_energy Interfaces public interface get_mbd_hamiltonian_energy Form and solve either a real or a complex MBD Hamiltonian. The real-typed version is equivalent to \\mathbf q=0 . \\begin{gathered}\n E_\\text{MBD}(\\mathbf q)=\\frac12\\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf\n q)}\\big)- 3\\sum_i\\frac{\\omega_i}2,\\qquad\n \\mathbf Q_{ij}(\\mathbf q)=\\omega_i&#94;2\\delta_{ij}\\mathbf I+\n \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}(\\mathbf q)\n \\\\ \\mathbf Q(\\mathbf q)\\equiv\n \\mathbf C(\\mathbf q)\\boldsymbol\\Lambda(\\mathbf q)\\mathbf C(\\mathbf\n q)&#94;\\dagger,\\qquad\n \\boldsymbol\\Lambda(\\mathbf q)\n \\equiv\\operatorname{diag}(\\{\\tilde\\omega_i(\\mathbf q)&#94;2\\}),\\qquad\n \\operatorname{Tr}\\big(\\sqrt{\\mathbf Q(\\mathbf q)}\\big)\n =\\sum_i\\tilde\\omega_i(\\mathbf q)\n \\end{gathered} \\begin{aligned}\n \\partial E_\\text{MBD}&=\\frac14\\operatorname{Tr}\\big(\n \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger\n \\partial\\mathbf Q\n \\big)-\n 3\\sum_i\\frac{\\partial\\omega_i}2\n \\\\ \\frac{\\partial E_\\text{MBD}}{\\partial X_i}&=\n \\operatorname{Re}\\frac12\\sum_{p\\zeta}(\n \\mathbf C\\boldsymbol\\Lambda&#94;{-\\frac12}\\mathbf C&#94;\\dagger\n )_{i\\zeta,p}\n \\frac{\\partial Q_{p,i\\zeta}}{\\partial X_i}-\n \\frac32\\frac{\\partial\\omega_i}{\\partial X_i}\n \\end{aligned} \\begin{aligned}\n \\partial\\mathbf Q_{ij}=&\n 2\\delta_{ij}\\omega_i\\partial\\omega_i\\mathbf I+\n \\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\\mathbf T_{ij}\\left(\n \\frac{\\partial\\omega_i}{\\omega_i}+\n \\frac{\\partial\\omega_j}{\\omega_j}+\n \\frac12\\frac{\\partial\\alpha_{0,i}}{\\alpha_{0,i}}+\n \\frac12\\frac{\\partial\\alpha_{0,j}}{\\alpha_{0,j}}\n \\right)\n \\\\ &+\\omega_i\\omega_j\\sqrt{\\alpha_{0,i}\\alpha_{0,j}}\n \\partial\\mathbf T_{ij}\n \\end{aligned} private function get_mbd_hamiltonian_energy_real(geom, alpha_0, omega, damp, dene, grad) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad Return Value type( result_t ) private function get_mbd_hamiltonian_energy_complex(geom, alpha_0, omega, damp, dene, grad, q) result(res) Arguments Type Intent Optional Attributes Name type( geom_t ), intent(inout) :: geom real(kind=dp), intent(in) :: alpha_0 (:) real(kind=dp), intent(in) :: omega (:) type( damping_t ), intent(in) :: damp type( grad_t ), intent(out) :: dene type( grad_request_t ), intent(in) :: grad real(kind=dp), intent(in) :: q (3) Return Value type( result_t )","tags":"","loc":"module/mbd_hamiltonian.html"}]}